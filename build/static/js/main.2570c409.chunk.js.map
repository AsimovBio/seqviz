{"version":3,"sources":["assets/empty-workspace-graphic-color.svg","PartExplorer/SeqViewer/partElementsToRows.js","Utils/colors.js","PartExplorer/SeqViewer/Circular/Annotations/Annotations.jsx","PartExplorer/SeqViewer/Circular/CircularFind/CircularFind.jsx","PartExplorer/SeqViewer/Circular/Index/Index.jsx","PartExplorer/SeqViewer/Circular/Labels/WrappedGroupLabel.jsx","PartExplorer/SeqViewer/Circular/Labels/Labels.jsx","PartExplorer/SeqViewer/Circular/Selection/Selection.jsx","PartExplorer/SeqViewer/handlers/eventRouter.jsx","PartExplorer/SeqViewer/handlers/selectionHandler.jsx","PartExplorer/SeqViewer/handlers/index.js","PartExplorer/SeqViewer/Circular/Circular.jsx","PartExplorer/SeqViewer/Linear/InfiniteScroll/InfiniteScroll.jsx","PartExplorer/SeqViewer/Linear/SeqBlock/Annotations/Annotations.jsx","PartExplorer/SeqViewer/Linear/SeqBlock/Index/Index.jsx","PartExplorer/SeqViewer/Linear/SeqBlock/LinearFind/LinearFind.jsx","PartExplorer/SeqViewer/Linear/SeqBlock/Selection/Selection.jsx","PartExplorer/SeqViewer/Linear/SeqBlock/SeqBlock.jsx","PartExplorer/SeqViewer/Linear/Linear.jsx","PartExplorer/SeqViewer/SeqViewer.jsx","BlankPage/BlankPage.jsx","Utils/sequence.js","PartExplorer/PartExplorer.jsx","App.js","serviceWorker.js","DefaultParts/pUC.js","index.js"],"names":["module","exports","__webpack_require__","p","last","arr","length","stackElements","elements","seqL","sortedElements","Object","toConsumableArray","sort","a","b","type","start","reduce","acc","insertIndex","findIndex","elems","end","newAcc","push","COLORS","COLOR_BORDER_MAP","#9DEAED","#8FDE8C","#CFF283","#8CDEBD","#F0A3CE","#F7C672","#F07F7F","#FAA887","#F099F7","#C59CFF","#6B81FF","#85A6FF","genRandomColor","randIndex","Math","floor","random","SingleAnnotation","props","annotation","seqLength","getRotation","generateArc","currBRadius","currTRadius","circularCentralIndex","lineHeight","transparentPath","inputRef","calcBorderColor","hoverAnnotation","annStyle","inlinedAnnotations","labelStyle","annLength","rotation","path","innerRadius","outerRadius","largeArc","sweepFWD","arrowFWD","direction","arrowREV","isInsert","annMiddle","bottomHalf","topLengthToMid","PI","bottomLengthToMid","lengthToMidpoint","circAnnID","concat","id","react","transform","assign","d","className","ref","element","fill","color","stroke","onMouseOver","onMouseOut","onFocus","onBlur","includes","dy","textAnchor","alignmentBaseline","startOffset","xlinkHref","name","Annotations","opacity","document","getElementById","getElementsByClassName","i","style","fillOpacity","fillColor","HslColor","tinycolor","toHsl","s","l","borderColor","toHex","_this2","this","_this$props","radius","rowsToSkip","Zoom","annotations","strokeWidth","shapeRendering","cursor","strokeLinejoin","anns","map","Annotations_SingleAnnotation","key","React","CircularFind","shouldComponentUpdate","nextProps","findState","_this","isEqual","createHighlight","result","selectionRows","resizing","searchIndex","resultLength","abs","topR","aAdjust","row","bAdjust","bottomR","findPath","resultStyle","index","shortid","generate","_this$props2","centralIndex","searchResults","threshold","firstBase","lastBase","tickCount","increments","indexInc","max","toPrecision","hideRender","Index","state","ticks","renderBasepairs","seq","compSeq","findCoor","seqForCircular","compSeqForCircular","basepairsToRender","charAt","center","size","yDiff","totalRows","mostInwardElementRadius","nameSpans","nameIndex","substring","trim","nameYAdjust","nameCoorRadius","nameCoor","x","y","height","tickCoorStart","tickCoorEnd","indexCircleStyle","tickLineStyle","tickTextStyle","fontWeight","indexCurve","fontSize","n","t","getDerivedStateFromProps","tickTolerance","filter","WrappedGroupLabel","group","setHoveredGroup","_this$props$size","width","calcRowWidth","label","CHAR_WIDTH","lastRow","labelRows","labels","nameWidth","maxCharPerRow","splitRegex","RegExp","splitLabelNameRows","match","forEach","splitLabel","objectSpread","groupHeight","groupWidth","_map","_map2","slicedToArray","rectHeight","rectWidth","forkCoor","textCoor","linePath","lineCoor","_group$textCoor","min","groupCoor","rectCoor","onMouseLeave","r","i2","tabIndex","Labels","labelGroups","hoveredGroup","setState","_this$state","hovered","find","g","first","fC","labelLines","grouped","onMouseEnter","WrappedGroupLabel_WrappedGroupLabel","prevState","groupOverlappingLabels","textRadius","labelsWithCoordinates","labelRow","annCenter","groupOverflows","nameLength","overflow","heightYPos","labelsGrouped","overlapIndex","leftNeighbor","rightNeighbor","undefined","newLabels","xDelta","yDelta","newTextCoor","some","apply","firstName","restLength","_g$textCoor","CircularSelection","_this$props$seqSelect","seqSelection","clockwise","selLength","lineTop","lineBottom","edgePath","sFlagF","lArc","selectPath","edgeStrokeWidth","edgeStyle","firstId","secondId","thirdId","eventRouter","WrappedComp","_class","_temp","_React$PureComponent","WithEventRouter","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","_delayedClick","clickedOnce","clickedTwice","componentDidMount","window","addEventListener","handleKeyPress","componentWillUnmount","removeEventListener","setEventRouter","suppressBrowserContextMenu","e","shiftKey","preventDefault","handleMouseEvent","selectAllHotkey","setPartState","handleTripleClick","resetClicked","mouseEvent","debounce","target","cancel","button","ctrlKey","ctxMenuClick","handleScrollEvent","Linear","delta","deltaY","newCentralIndex","showSearch","clipboardCopy","_this$props3","_this$props3$seqSelec","formerFocus","activeElement","tempNode","createElement","innerText","body","appendChild","select","execCommand","remove","focus","keypressMap","handleSeqInteraction","_ref","asyncToGenerator","regenerator_default","mark","_callee","_this$props4","_this$props$bpsPerBlo","bpsPerBlock","_this$props5","selection","_this$props6","_selection","_this$props6$findStat","currIdx","_setPartState","nextIdx","nextResults","nextSelectStart","nextSelectEnd","newPos","selectionLength","wrap","_context","prev","next","t0","abrupt","linearCentralIndex","startsWith","stop","_x","arguments","keyType","replace","inherits","createClass","value","onMouseMove","onKeyDown","onWheel","role","displayName","withEventRouter","selectionHandler","_React$Component","_getPrototypeOf2","_len","args","Array","_key","previousBase","forward","fullSelectionLength","dragEvent","selectionStarted","shiftSelection","timestamp","lastMouseX","lastMouseY","workspace","allowSetSelection","elementIdsToRanges","Map","mountedBlocks","Set","stopDrag","getElement","elemId","get","resetCircleDragVars","calcSelectionLength","base","clock","calculateBaseLinear","knownRange","block","currentTarget","getBoundingClientRect","percFromLeft","clientX","left","bpsFromLeft","round","calculateBaseCircular","distFromLeft","distFromTop","clientY","top","riseToRun","posInDeg","atan","posInPerc","currBase","addMountedBlock","add","removeMountedBlock","delete","mapIdToRange","selectRange","set","setSequenceSelection","_selectRange$clockwis","_selectRange$start","_selectRange$end","_selectRange$ref","_selectRange$type","_selectRange$searchIn","newSearchIndex","newSelection","findStateIndex","updateSelectionWithknownRange","selectionStart","selectionEnd","res","currSelection","clockwiseDrag","newStart","newEnd","newRef","newClockwise","selStart","lookaheadc","increased","changeThreshold","change","crossedZero","lengthChange","sameDirectionMove","check","sameDirectionDrag","alreadyFullSelection","hitFullSelection","onUnMount","withSelectionHandler","handlers","WrappedViewer","Circular","annotationsInRows","inlinedLabels","outerLabels","rotate","hideHeader","radians","xAdjust","cos","yAdjust","sin","rotateCoor","coor","degrees","angle","xDiff","_ref$sweepFWD","_ref$arrowFWD","_ref$arrowREV","_ref$offset","offset","leftBottom","leftTop","rightBottom","rightTop","leftArrow","rightArrow","centralAngle","centralAngleDeg","lArrowC","rArrowC","sFlagR","showAnnotations","showAxis","Axis","partState","_this$state2","general","plasmidId","selectionId","onMouseDown","onMouseUp","Selection","onUnmount","Index_Index","Circular_CircularFind_CircularFind","Annotations_Annotations","Labels_Labels_Labels","ann","circumf","annNameLengthPixels","annLengthBases","withViewerHOCs","InfiniteScroll","handleScrollOrResize","componentDidUpdate","prevProps","snapshot","scroller","seqBlocks","visibleBlocks","scrollToCentralIndex","restoreSnapshot","getSnapshotBeforeUpdate","current","scrollTop","blockHeights","blockIndex","accumulatedY","blockY","totalHeight","_this$scroller$curren","clientHeight","scrollHeight","centerBlockIndex","newVisibleBlocks","centerBlock","topAdjust","bottom","total","h","slice","insideDOM","incrementScroller","incAmount","stopIncrementingScroller","timeoutID","setTimeout","clearTimeout","handleMouseOver","buttons","scrollerBlock","percFromTop","scaledPerc","scaledScroll","firstRendered","spaceAbove","onScroll","require","AnnotationRow","hoverOtherAnnotationRows","renderAnnotation","seqBlockRef","findXAndWidth","fullSeq","reverse","_findXAndWidth","origX","crossZero","endFWD","endREV","overflowLeft","overflowRight","_findXAndWidth2","_findXAndWidth3","_findXAndWidth4","_findXAndWidth5","strokeColor","rectProps","textProps","textRendering","cH","w","topLeft","topRight","bottomRight","bottomLeft","annotationPath","nameFits","gTranslate","AnnotationRows","annotationRows","elementHeight","Annotations_AnnotationRow","genTicks","tallies","talPositions","tickStyle","textStyle","leftDist","tickFromLeft","textFromLeft","digits","ceil","log10","textWidth","transTick","transText","react_default","Fragment","axisStyle","PureComponent","LinearFind","searchRows","indexYDiff","compYDiff","currSearchIndex","findProps","selReference","Selection_Selection","Edges","selectEdgeHeight","startEdge","lastEdge","secondEdgeX","rect","Block","_getPrototypeOf3","_len2","_key2","selectHeight","secondBlock","secBlockX","secBlockWidth","_findXAndWidth6","_findXAndWidth7","_findXAndWidth8","_findXAndWidth9","_findXAndWidth10","_findXAndWidth11","rectId","SeqBlock","firstIndex","lastIndex","blockHeight","seqFontSize","zoomed","svgProps","display","dominantBaseline","lengthAdjust","textLength","seqRange","indexHeight","compHeight","annYDiff","annHeight","indexRowYDiff","Annotations_AnnotationRows","SeqBlock_LinearFind_LinearFind","Index_Index_Index","defaultProps","rest","objectWithoutProperties","origRest","_this$props2$findStat","_this$props2$findStat2","Zoomed","arrSize","Number","POSITIVE_INFINITY","ids","seqs","compSeqs","yDiffs","rowLength","rowCount","newArr","j","k","createMultiRows","duplicateIdsAllowed","_loop","_elements$_i","sequenceCutIdx","_elements$_i2","complementCutIdx","rowEnd","every","el","createSingleRows","yDiffCumm","spacingHeight","blockSize","SeqBlock_SeqBlock","InfiniteScroll_InfiniteScroll","SeqViewer","nextState","unsub","seqStateChange","_e$target","defineProperty","checked","part","linearProps","_this$state$Zoom","WIDTH_MULTIPLIER","charWidth","circularProps","_this$state$Zoom2","oldSize","limitingDim","beta","exp","log","pow","bpsOnArc","maxPixelPerBP","minPixelPerBP","totalPixelsOfArc","radiusAdjust","CircularProp","zIndex","SeqViewer_Circular_Circular","SeqViewer_Linear_Linear","options","linear","checkBoxes","sliders","circular","sizeMe","monitorWidth","monitorHeight","BlankPage","src","blankImg","alt","annotationFactory","PartExplorer","onSelection","onSelectionFunction","newState","keys","esm_extends","lambdaAnnotate","err","Promise","resolve","reject","request","post","uri","String","process","REACT_APP_LAMBDA_URL","method","json","JSON","stringify","headers","Content-Type","resp","console","toJSON","sent","statusCode","Error","autoAnnotate","_callee2","_context2","annotate","PartExplorer_SeqViewer_SeqViewer","src_BlankPage_BlankPage","lattice","src_PartExplorer_PartExplorer","Viewer","App_Circular","App_Linear","Boolean","location","hostname","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2570c409.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/empty-workspace-graphic-color.ca1a77b9.svg\";","// utility funcs for annotationsToRows\nconst last = arr => arr[arr.length - 1];\nconst first = arr => arr[0];\n\n/**\n * annotationsToRows\n * takes an array of annotations (a one deep array) and creates an array of\n * array of annotations, where non-overlapping annotations can be in the same\n * row. Example:\n * input (one array):\n * \t\t[ ---Ann---\t---Ann3---\n * \t\t\t ---Ann2--- ]\n *\n * output (array of array):\n * \t\t[ ---Ann--- ---Ann3---]\n * \t\t[\t\t---Ann2---    ]\n *\n * @param {[Annotation]} annotations   all annotations in a single row\n * @return {[[Annotation]]}            annotations grouped into a single array if they're\n *                                     non-overlapping\n */\nexport const stackElements = (elements, seqL) => {\n  const sortedElements = [...elements];\n  sortedElements.sort((a, b) => {\n    // prioritize insert annotations for tiebreakers so that the insert annotation appears\n    // above the annotations spanning the whole insert\n    if (a.type === \"insert\" && a.start === b.start) {\n      return -1;\n    }\n    if (b.type === \"insert\" && a.start === b.start) {\n      return 1;\n    }\n    return a.start - b.start;\n  });\n\n  return sortedElements.reduce((acc, a) => {\n    const insertIndex = acc.findIndex(elems => {\n      if (a.end === a.start) {\n        // the element has the same start and end index and therefore the whole\n        // plasmid (so it shouldn't fit into any existing row)\n        return false;\n      }\n      if (last(elems).end <= last(elems).start) {\n        // the last annotation in this row crosses zero index\n        return last(elems).end + seqL <= a.start;\n      }\n      if (a.end > a.start) {\n        // this annotation doesn't cross the zero index and the last in row doesn't\n        return last(elems).end <= a.start;\n      }\n      // both this curr anntoation and the last in the row cross the zero index\n      return last(elems).end < a.start && a.end < first(elems).start;\n    });\n    const newAcc = [...acc];\n    if (insertIndex > -1) {\n      // insert in the row where it's the new highest\n      newAcc[insertIndex].push(a);\n    } else {\n      // create a new row for this entry\n      newAcc.push([a]);\n    }\n    return newAcc;\n  }, []);\n};\n\n/**\n * given an array of arrays of an element, fragment the element into seq blocks\n *\n * this is needed in the Linear sequence viewer because it's easier to send only the\n * relevant elements to the childSeqBlock, rather to send every SeqBlock everything\n * and have the block figure out whether element is included within it\n *\n * NOTE: if an element has a start and end index that are the same, it's assumed to\n * cover the entire plasmid\n *\n * @param {[Annotation | ORF]}\n * @return {[[Annotation | ORF]]}\n */\nexport const createMultiRows = (elements, rowLength, rowCount) => {\n  const newArr = new Array(rowCount);\n\n  // initialize the nested rows in each block\n  for (let i = 0; i < rowCount; i += 1) {\n    newArr[i] = [];\n    for (let j = 0; j < elements.length; j += 1) {\n      newArr[i][j] = [];\n    }\n  }\n\n  // for each row of input\n  for (let i = 0; i < elements.length; i += 1) {\n    // for each annotation|ORF in that row\n    for (let j = 0; j < elements[i].length; j += 1) {\n      // if the element doesn't cross the zero index\n      if (elements[i][j].start < elements[i][j].end) {\n        // between the elements start and end, add to every seqBlock\n        // within its range\n\n        // this element doesn't cross the zero index and doesn't cover\n        // the whole plasmid\n        let k = Math.max(0, Math.floor(elements[i][j].start / rowLength));\n        const end = Math.floor((elements[i][j].end - 1) / rowLength);\n\n        while (k <= end && k < rowCount) {\n          newArr[k][i].push(elements[i][j]);\n          k += 1;\n        }\n      } else if (elements[i][j].end < elements[i][j].start) {\n        // the element crosses the zero index and doesn't cover the whole\n        // plasmid\n\n        // first, push onto all arrays from the end down to the zero\n        let e = Math.floor(elements[i][j].end / rowLength);\n        // handle an edge case\n        if (elements[i][j].end === 0) e = -1; // skip adding to rows\n        while (e >= 0 && e < newArr.length) {\n          newArr[e][i].push(elements[i][j]);\n          e -= 1;\n        }\n\n        // then push onto all arrays from the start to the end\n        let s = Math.floor(elements[i][j].start / rowLength);\n        while (s < rowCount) {\n          newArr[s][i].push(elements[i][j]);\n          s += 1;\n        }\n      } else if (elements[i][j].end === elements[i][j].start) {\n        // the element circles the entire plasmid and, therefore, fills every\n        // SeqBlock. start === end is signal for covering whole plasmid\n        for (let a = 0; a < newArr.length; a += 1) {\n          newArr[a][i].push(elements[i][j]);\n        }\n\n        // and add again for the block that the element starts in\n        const s = Math.floor(elements[i][j].start / rowLength);\n        newArr[s][i].push(elements[i][j]);\n      }\n    }\n  }\n\n  // filter out the empty rows in each block\n  for (let i = 0; i < rowCount; i += 1) {\n    newArr[i] = newArr[i].filter(a => a[0]);\n  }\n\n  return newArr;\n};\n\n/**\n * search thru the map w/ the given interval finding all relevant\n * annotations/ORFs/etc by finding the appropriate start and end range\n * using Math.floor\n *\n * @param {CreateRowInfo}\n * @return {[[Object]]}       an array of an array of the values that were stored on creation\n */\nexport const createSingleRows = (\n  elements,\n  rowLength,\n  rowCount,\n  duplicateIdsAllowed = true\n) => {\n  const newArr = new Array(rowCount);\n\n  // initialize the nested rows in each block\n  for (let i = 0; i < rowCount; i += 1) {\n    newArr[i] = [];\n  }\n\n  // assign each annotation to its respective array\n  for (let i = 0; i < elements.length; i += 1) {\n    let { start, end } = elements[i];\n\n    // special case for enzymes that have cutsites away from recog (BsaI)\n    if (elements[i].sequenceCutIdx !== undefined) {\n      const { sequenceCutIdx, complementCutIdx } = elements[i];\n      start =\n        sequenceCutIdx > end || sequenceCutIdx < start ? sequenceCutIdx : start;\n      end =\n        complementCutIdx > end || complementCutIdx < start\n          ? complementCutIdx\n          : end;\n    }\n\n    if (start < end) {\n      let k = Math.floor(start / rowLength);\n      const rowEnd = Math.floor(end / rowLength);\n\n      while (k <= rowEnd && k < rowCount) {\n        newArr[k].push(elements[i]);\n        k += 1;\n      }\n    } else {\n      // the element crosses the zero index\n      // first, push onto all arrays from the end down to the zero\n      let e = Math.floor(end / rowLength);\n      while (e >= 0) {\n        newArr[e].push(elements[i]);\n        e -= 1;\n      }\n\n      // then push onto all arrays from the start to the end\n      let s = Math.floor(start / rowLength);\n      while (s < rowCount) {\n        // only add to the array if the user is okay with having duplicates by id.\n        // for example, this shouldn't be allowed if multiple translation rows have\n        // the same ID\n        if (\n          duplicateIdsAllowed ||\n          newArr[s].every(el => el.id !== elements[i].id)\n        ) {\n          newArr[s].push(elements[i]);\n        }\n        s += 1;\n      }\n    }\n  }\n\n  return newArr;\n};\n","/**\n * @typedef {COLORS}\n * @type {Array<String>}\n *\n * a color pallete of colors (for LinearSeq right now)\\\n * generated using:\n * https://material.io/color/#!/?view.left=0&view.right=0&primary.color=FFCC80\n */\nexport const COLORS = [\n  \"#9DEAED\", // cyan\n  \"#8FDE8C\", // green\n  \"#CFF283\", // light green\n  \"#8CDEBD\", // teal\n  \"#F0A3CE\", // pink\n  \"#F7C672\", // orange\n  \"#F07F7F\", // red\n  \"#FAA887\", // red-orange\n  \"#F099F7\", // magenta\n  \"#C59CFF\", // purple\n  \"#6B81FF\", // blue\n  \"#85A6FF\" // light blue\n];\n\nexport const COLOR_BORDER_MAP = {\n  \"#9DEAED\": \"#5EB5B8\", // cyan\n  \"#8FDE8C\": \"#5CA35A\", // green\n  \"#CFF283\": \"#8DB041\", // light green\n  \"#8CDEBD\": \"#4CA17F\", // teal\n  \"#F0A3CE\": \"#BD6295\", // pink\n  \"#F7C672\": \"#BD872B\", // orange\n  \"#F07F7F\": \"#AD4040\", // red\n  \"#FAA887\": \"#B36446\", // red-orange\n  \"#F099F7\": \"#AB63B0\", // magenta\n  \"#C59CFF\": \"#8A60C4\", // purple\n  \"#6B81FF\": \"#2E3B85\", // blue\n  \"#85A6FF\": \"#4C66AD\" // light blue\n};\n\nexport const INSERT_COLORS = [\n  \"#6bdbdc\", // insert 1\n  \"#a066c9\", // insert 2\n  \"#bbd44c\", // insert 3\n  \"#f3995b\" // insert 4\n];\n\n// color generator function\nexport const genRandomColor = () => {\n  const randIndex = Math.floor(Math.random() * COLORS.length);\n  return COLORS[randIndex];\n};\n\n/** get an \"indexed\" color from the colors array */\nexport const colorByIndex = (i) => COLORS[i % COLORS.length];\n\n/** get an \"indexed\" color from the colors array */\nexport const borderColorByIndex = (i) =>\n  COLOR_BORDER_MAP[COLORS[i % COLORS.length]];\n","import { COLOR_BORDER_MAP } from \"../../../../Utils/colors\";\nimport * as React from \"react\";\nimport tinycolor from \"tinycolor2\";\n\n/**\n * A component for a single annotation within the Circular Viewer\n *\n * @param {AnnotationProps} props for a single Annotation\n */\nconst SingleAnnotation = props => {\n  const {\n    annotation: a,\n    seqLength,\n    getRotation,\n    generateArc,\n    currBRadius,\n    currTRadius,\n    circularCentralIndex,\n    lineHeight,\n    transparentPath,\n    inputRef,\n    calcBorderColor,\n    hoverAnnotation,\n    annStyle,\n    inlinedAnnotations,\n    labelStyle\n  } = props;\n\n  // if it crosses the zero index, correct for actual length\n  let annLength =\n    a.end >= a.start ? a.end - a.start : seqLength - a.start + a.end;\n\n  // can't make an arc from a full circle\n  annLength = annLength === 0 ? seqLength - 0.1 : annLength;\n\n  // how many degrees should it be rotated?\n  const rotation = getRotation(a.start);\n\n  const path = generateArc({\n    innerRadius: currBRadius,\n    outerRadius: currTRadius,\n    length: annLength,\n    largeArc: annLength > seqLength / 2,\n    sweepFWD: true,\n    arrowFWD: a.direction === \"FORWARD\",\n    arrowREV: a.direction === \"REVERSE\",\n    isInsert: a.type === \"insert\"\n  });\n\n  // determine whether the annotation's name is in the top or bottom\n  // half of the plasmid (used in rendering inline annotation)\n  const annMiddle =\n    (annLength / 2 + a.start + seqLength - circularCentralIndex) % seqLength; // in bps\n  const bottomHalf =\n    annMiddle > seqLength * 0.25 && annMiddle < seqLength * 0.75;\n\n  // find the length from the start of the arc to its middle to adjust the name inward\n  const topLengthToMid = Math.PI * (annLength / seqLength) * currBRadius;\n  const bottomLengthToMid = Math.PI * (annLength / seqLength) * currTRadius;\n  let lengthToMidpoint = topLengthToMid;\n  if (!bottomHalf) {\n    lengthToMidpoint += topLengthToMid + bottomLengthToMid;\n    if (a.direction === \"REVERSE\") {\n      lengthToMidpoint += 0.75 * lineHeight;\n    } else if (a.direction === \"NONE\") {\n      lengthToMidpoint += lineHeight;\n    }\n  }\n\n  const circAnnID = `${a.id}-circular`;\n  return (\n    <g id={`${a.id}-annotation-circular`} transform={rotation}>\n      <path id={circAnnID} d={path} {...transparentPath} />\n      <path\n        d={path}\n        id={a.id}\n        className={a.id}\n        ref={inputRef(a.id, {\n          ref: a.id,\n          start: a.start,\n          end: a.end,\n          type: \"ANNOTATION\",\n          element: null\n        })}\n        fill={a.color}\n        stroke={\n          COLOR_BORDER_MAP[a.color]\n            ? COLOR_BORDER_MAP[a.color]\n            : calcBorderColor(a.color)\n        }\n        onMouseOver={() => hoverAnnotation(a.id, 1.0)}\n        onMouseOut={() => hoverAnnotation(a.id, 0.7)}\n        onFocus={() => {}}\n        onBlur={() => {}}\n        {...annStyle}\n      />\n      {inlinedAnnotations.includes(a.id) && (\n        <text\n          id={a.id}\n          dy={-0.4 * lineHeight}\n          onMouseOver={() => hoverAnnotation(a.id, 1.0)}\n          onMouseOut={() => hoverAnnotation(a.id, 0.7)}\n          onFocus={() => {}}\n          onBlur={() => {}}\n        >\n          <textPath\n            id={a.id}\n            textAnchor=\"middle\"\n            alignmentBaseline=\"middle\"\n            startOffset={lengthToMidpoint}\n            xlinkHref={`#${circAnnID}`}\n            {...labelStyle}\n          >\n            {a.name}\n          </textPath>\n        </text>\n      )}\n    </g>\n  );\n};\n\n/**\n * Used to build up all the path elements. Does not include a display\n * of the annotation name or a line connecting name to annotation\n *\n * one central consideration here is that annotations might overlap with one another.\n * to avoid having those overalp visually, annotations are first moved into rows,\n * which are non-overlapping arrays or annotation arrays, which are then\n * used to create the array of array of annotation paths\n *\n * When the Zoom is greater than 5, show the annotation names in the annotations\n * (move them to within the annotation)\n *\n * @type {Function}\n */\nexport default class Annotations extends React.PureComponent {\n  /** during an annotation hover event, darken all other pieces of the same annotation */\n  hoverAnnotation = (className, opacity) => {\n    const elements = document\n      .getElementById(\"circular-annotations\")\n      .getElementsByClassName(className);\n    for (let i = 0; i < elements.length; i += 1) {\n      elements[i].style.fillOpacity = opacity;\n    }\n  };\n\n  /** given the interior color of an annotation, calculate the color of its border */\n  calcBorderColor = fillColor => {\n    const tColor = tinycolor(fillColor);\n    const HslColor = tColor.toHsl();\n    HslColor.s = HslColor.s + 0.1 > 1 ? (HslColor.s = 1) : (HslColor.s += 0.1);\n    HslColor.l -= 0.26;\n    const borderColor = tinycolor(HslColor);\n    return `#${borderColor.toHex()}`;\n  };\n\n  render() {\n    const { radius, rowsToSkip, Zoom, lineHeight, annotations } = this.props;\n\n    // at least 3 rows inward from default radius (ie index row)\n    const rowShiftHeight = lineHeight * rowsToSkip;\n    const radiusAdjust = lineHeight * 3;\n    let currBRadius = radius - radiusAdjust - rowShiftHeight;\n\n    // increasing the size of the annotations during a \"zoom\"\n    let currTRadius = currBRadius - lineHeight; // top radius\n\n    // shared style object for inlining\n    const annStyle = {\n      strokeWidth: Zoom > 30 ? 1 : 0.5,\n      shapeRendering: \"geometricPrecision\",\n      cursor: \"pointer\",\n      fillOpacity: 0.7,\n      strokeLinejoin: \"round\"\n    };\n    // this is strictly here to create an invisible path that the\n    // annotation name can follow\n    const transparentPath = {\n      stroke: \"transparent\",\n      fill: \"transparent\"\n    };\n    const labelStyle = {\n      cursor: \"pointer\"\n    };\n\n    return (\n      <g id=\"circular-annotations\">\n        {annotations.reduce((acc, anns, i) => {\n          if (i) {\n            currBRadius -= lineHeight + 3;\n            currTRadius -= lineHeight + 3;\n          } // increment the annRow radii if on every loop after first\n\n          return acc.concat(\n            anns.map(a => (\n              <SingleAnnotation\n                {...this.props}\n                key={`${a.id}-annotation-circular-row`}\n                id={`${a.id}-annotation-circular-row`}\n                annotation={a}\n                currBRadius={currBRadius}\n                currTRadius={currTRadius}\n                transparentPath={transparentPath}\n                labelStyle={labelStyle}\n                annStyle={annStyle}\n                hoverAnnotation={this.hoverAnnotation}\n                calcBorderColor={this.calcBorderColor}\n              />\n            ))\n          );\n        }, [])}\n      </g>\n    );\n  }\n}\n","import { isEqual } from \"lodash\";\nimport * as React from \"react\";\nimport shortid from \"shortid\";\n\nclass CircularFind extends React.Component {\n  shouldComponentUpdate = nextProps => {\n    const { findState } = this.props;\n\n    return !isEqual(findState, nextProps.findState);\n  };\n\n  createHighlight = result => {\n    const {\n      Zoom,\n      radius,\n      selectionRows,\n      lineHeight,\n      seqLength,\n      getRotation,\n      generateArc,\n      resizing,\n      inputRef,\n      findState: { searchIndex }\n    } = this.props;\n    let { start, end } = result;\n    // crosses the zero index\n    if (end < start) end += seqLength;\n\n    const resultLength = Math.abs(end - start);\n\n    // const calc the size of the result radii\n    let topR = radius + lineHeight; // outer radius\n\n    // adjustment for the top/bottom of the rectangle, based on row number\n    const aAdjust = result.row > 0 ? lineHeight / 2 : lineHeight * 1.5;\n    let bAdjust = result.row > 0 ? lineHeight / 1.5 : lineHeight * 1.7;\n\n    let bottomR = radius + bAdjust;\n    if (Zoom > 60 || seqLength < 200) {\n      topR += aAdjust;\n    } else {\n      topR += 1.3 * lineHeight;\n      bAdjust = lineHeight * selectionRows;\n      bottomR = radius - bAdjust / 4;\n    }\n\n    const findPath = generateArc({\n      innerRadius: bottomR,\n      outerRadius: topR,\n      length: resultLength,\n      largeArc: resultLength > seqLength / 2,\n      sweepFWD: true\n    });\n\n    const fill =\n      result.index === searchIndex\n        ? \"rgba(255, 165, 7, 0.5)\"\n        : \"rgba(255, 251, 7, 0.5)\";\n\n    const resultStyle = {\n      stroke: \"black\",\n      strokeWidth: 0.8,\n      fill: fill,\n      shapeRendering: resizing ? \"optimizeSpeed\" : \"auto\",\n      cursor: \"pointer\"\n    };\n\n    const id = shortid.generate();\n\n    return (\n      <path\n        d={findPath}\n        key={shortid.generate()}\n        transform={getRotation(result.start)}\n        {...resultStyle}\n        id={id}\n        ref={inputRef(id, {\n          ref: id,\n          start: result.start,\n          end: result.end,\n          type: \"FIND\"\n        })}\n      />\n    );\n  };\n\n  render() {\n    const {\n      Zoom,\n      seqLength,\n      circularCentralIndex: centralIndex,\n      findState: { searchResults }\n    } = this.props;\n    const threshold =\n      seqLength >= 200 ? searchResults.length / seqLength <= 0.01 : true;\n\n    let firstBase = 0;\n    let lastBase = seqLength;\n    if (Zoom > 60) {\n      // equation of a line from (0, 4) to (100, seqLength / 10) (Zoom, tickCount)\n      const tickCount = ((seqLength / 10.0 - 4.0) / 100.0) * Zoom + 4;\n\n      // make each increment a multiple of 10 with two sig figs\n      const increments = Math.floor(seqLength / tickCount);\n      let indexInc = Math.max(+increments.toPrecision(2), 10);\n      while (indexInc % 10 !== 0) indexInc += 1;\n\n      firstBase = centralIndex - indexInc * 5;\n      lastBase = centralIndex + indexInc * 5;\n      if (centralIndex < seqLength / 2) {\n        firstBase += seqLength;\n        lastBase += seqLength;\n      }\n    }\n    return searchResults.length ? (\n      <g id=\"circular-find-results\">\n        {searchResults.map(s => {\n          const hideRender =\n            s.start < firstBase && s.start > lastBase - seqLength;\n          if (Zoom > 60 && hideRender) return null;\n          if (Zoom < 60 && !threshold) return null;\n          return this.createHighlight(s, threshold);\n        })}\n      </g>\n    ) : null;\n  }\n}\n\nexport default CircularFind;\n","import * as React from \"react\";\n\n/**\n * this component renders the following:\n * \t\t1. the Name of the part (center or bottom)\n * \t\t2. the number of bps (center or bottom)\n * \t\t3. the plasmid circle\n * \t\t4. the index numbers along the plasmid circle\n *\n * center or bottom here refers to the fact that the name/bps of the\n * part need to be pushed to the bottom of the circular viewer if there\n * are too many elements in the circular viewer and the name won't fit\n */\nexport default class Index extends React.PureComponent {\n  static getDerivedStateFromProps = nextProps => {\n    const { circularCentralIndex: centralIndex, seqLength, Zoom } = nextProps;\n    // equation of a line from (0, 6) to (100, seqLength / 10) (Zoom, tickCount)\n    // ie, at min zoom, 6 ticks. at max zoom, one tick every 10 bps\n    const tickCount = ((seqLength / 10.0 - 6.0) / 100.0) * Zoom + 6;\n\n    // make each increment a multiple of 10 with two sig figs\n    const increments = Math.floor(seqLength / tickCount);\n    let indexInc = Math.max(+increments.toPrecision(2), 10);\n    while (indexInc % 10 !== 0) indexInc += 1;\n\n    // make all the ticks. Also, only keep ticks that are +/- 6 tick incremenets from the top\n    // centralIndex, as the others won't be shown/rendered anyway\n    let ticks = [];\n    for (let i = 0; i <= seqLength - indexInc / 2; i += indexInc) {\n      ticks.push(i === 0 ? 1 : i);\n    }\n    const tickTolerance = indexInc * 6;\n    ticks = ticks.filter(\n      t =>\n        Math.abs(centralIndex - t) < tickTolerance ||\n        Math.abs(centralIndex + seqLength - t) < tickTolerance ||\n        Math.abs(centralIndex - seqLength - t) < tickTolerance\n    );\n    return { ticks, indexInc };\n  };\n\n  state = {\n    ticks: [],\n    indexInc: 10\n  };\n\n  /**\n   * return a react element for the basepairs along the surface of the plasmid viewer\n   */\n  renderBasepairs = () => {\n    const {\n      seq,\n      compSeq,\n      circularCentralIndex: centralIndex,\n      seqLength,\n      lineHeight,\n      radius,\n      findCoor,\n      getRotation\n    } = this.props;\n    const { indexInc } = this.state;\n\n    // at max zoom we should show ~50 basepairs across the width of the viewer,\n    // \twith a tick every 10bps\n    // at min zoom we should show all basepairs, with only 4 ticks\n    const seqForCircular = seq + seq;\n    const compSeqForCircular = compSeq + compSeq;\n    let firstBase = centralIndex - indexInc * 5;\n    let lastBase = centralIndex + indexInc * 5;\n    if (centralIndex < seqLength / 2) {\n      firstBase += seqLength;\n      lastBase += seqLength;\n    }\n    const basepairsToRender = [];\n    for (let i = firstBase; i <= lastBase; i += 1) {\n      basepairsToRender.push(\n        <text\n          key={`base_${i}`}\n          {...findCoor(0, radius + 2 * lineHeight)}\n          transform={getRotation(i + 0.25)}\n        >\n          {seqForCircular.charAt(i)}\n        </text>,\n        <text\n          key={`base_comp_${i}`}\n          {...findCoor(0, radius + lineHeight)}\n          transform={getRotation(i + 0.25)}\n        >\n          {compSeqForCircular.charAt(i)}\n        </text>\n      );\n    }\n    return basepairsToRender;\n  };\n\n  render() {\n    const {\n      seq,\n      name,\n      Zoom,\n      radius,\n      center,\n      size,\n      yDiff,\n      seqLength,\n      lineHeight,\n      getRotation,\n      generateArc,\n      findCoor,\n      resizing,\n      totalRows\n    } = this.props;\n    const { ticks } = this.state;\n    // split up the name so it fits within spans in the center\n    // 30 letters is arbitrary. would be better to first search for \"cleaveable characters\"\n    // like \"|\" or \",\" and revert to all chars if those aren't found. Or to decrease\n    // name size first before cleaving, etc\n    const mostInwardElementRadius = radius - totalRows * lineHeight;\n    const cutoff = 30;\n    const nameSpans = [];\n    let nameIndex = 0;\n    // TODO: react freaks out when the circ viewer is small and each line is one char\n    // bc there are shared keys (also it's just not a good look)\n    while (nameIndex < name.length) {\n      nameSpans.push(name.substring(nameIndex, nameIndex + cutoff).trim());\n      nameIndex += cutoff;\n    }\n\n    // generate the name text for the middle of the plasmid\n    const spanCountAdjust = 20 * nameSpans.length; // adjust for each tspan off name\n    const nameYAdjust = 14 + spanCountAdjust; // correct for both\n    const nameCoorRadius = (nameSpans[0].length / 2) * 12; // 12 px per character\n\n    // if the viewer is at all zoomed, or if the elements will begin to overlap with the\n    // name, move the name downward to the bottom of the viewer\n    const nameCoor =\n      Zoom > 2 || nameCoorRadius > mostInwardElementRadius\n        ? {\n            x: center.x,\n            y: size.height - nameYAdjust - yDiff\n          }\n        : {\n            x: center.x,\n            y: center.y - ((nameSpans.length - 1) / 2) * 25 // shift the name up for >1 rows of text\n          };\n\n    // these are just created once, but are rotated to each position along the plasmid\n    const tickCoorStart = findCoor(0, radius);\n    // constant tick height, doesn't scale w/ lineHeight/Zoom\n    const tickCoorEnd = findCoor(0, radius - 10);\n\n    // create tick and text style\n    const nameStyle = {\n      fontSize: 20,\n      textAnchor: \"middle\",\n      fontWeight: 500\n    };\n    const subtitleStyle = {\n      fontSize: 14,\n      textAnchor: \"middle\",\n      alignmentBaseline: \"hanging\",\n      fill: \"gray\"\n    };\n    const indexCircleStyle = {\n      fill: \"transparent\",\n      stroke: \"#73777D\",\n      strokeWidth: 3\n    };\n    const tickLineStyle = {\n      fill: \"transparent\",\n      stroke: \"black\",\n      strokeWidth: 2.5,\n      shapeRendering: resizing ? \"optimizeSpeed\" : \"geometricPrecision\"\n    };\n    const tickTextStyle = {\n      textAnchor: \"middle\",\n      alignmentBaseline: \"hanging\",\n      fontWeight: 500\n    };\n\n    // generate the full circle around the edge of the plasmid (when too zoomed out to see DNA)\n    const indexCurve = generateArc({\n      innerRadius: radius,\n      outerRadius: radius,\n      length: seqLength / 2,\n      largeArc: true\n    });\n    return (\n      <g id=\"circular-index\">\n        <text {...nameStyle}>\n          {nameSpans.map((n, i) => (\n            <tspan key={n} x={nameCoor.x} y={nameCoor.y + i * 25}>\n              {n}\n            </tspan>\n          ))}\n        </text>\n        <text\n          x={nameCoor.x}\n          y={nameCoor.y + 14 + 25 * (nameSpans.length - 1)}\n          {...subtitleStyle}\n        >\n          {`${seqLength} bp`}\n        </text>\n        {Zoom > 60 || seq.length < 200 ? (\n          <g className=\"circular-bps\">{this.renderBasepairs()}</g>\n        ) : null}\n        {ticks.map(t => (\n          <g key={`${t}_tick`} transform={getRotation(t - 0.5)}>\n            <path\n              d={`M ${tickCoorStart.x} ${tickCoorStart.y}\n                L ${tickCoorEnd.x} ${tickCoorEnd.y}`}\n              {...tickLineStyle}\n            />\n            <text x={tickCoorEnd.x} y={tickCoorEnd.y + 4} {...tickTextStyle}>\n              {t}\n            </text>\n          </g>\n        ))}\n        <g>\n          <path\n            d={indexCurve}\n            transform={getRotation(seqLength * 0.75)}\n            {...indexCircleStyle}\n          />\n          <path\n            d={indexCurve}\n            transform={getRotation(seqLength * 0.25)}\n            {...indexCircleStyle}\n          />\n        </g>\n      </g>\n    );\n  }\n}\n","import * as React from \"react\";\n\nimport { CHAR_WIDTH } from \"../Circular\";\n\n/**\n * a component that groups several other labels together so they're all viewable at once\n */\nexport default class WrappedGroupLabel extends React.Component {\n  /**\n   * given the currently active annotation block, with multiple annotations and enzymes,\n   * render each in a single \"block\", which is a g element with a rect \"containing\" the\n   * names. This is slightly tricky because we can't put the text elements inside\n   * the rect as though it were a div and have them fill it. instead, we must calculate\n   * the height and width of the resulting annotaiton block\n   */\n  render() {\n    const {\n      group,\n      setHoveredGroup,\n      lineHeight,\n      size: { height, width },\n      Zoom\n    } = this.props;\n\n    // utility function for calculating the width of the last row before this one\n    // the +1 after name.length is for a comma\n    const calcRowWidth = row =>\n      row.reduce((acc, label) => acc + (label.name.length + 1) * CHAR_WIDTH, 0);\n\n    // group the labels into rows with a preference with widths less than 200px\n    const lastRow = acc => acc[acc.length - 1];\n    const labelRows = group.labels.reduce((acc, l) => {\n      const nameWidth = l.name.length * CHAR_WIDTH;\n      if (nameWidth > width) {\n        // handle an edge case where the annotation name is MASSIVE and\n        // greater than the width of the sequence viewer\n        // split the name into separate rows so it's at max 75% of the\n        // seq viewer's width, but each still referencing the original label\n        const maxCharPerRow = Math.floor((width * 0.75) / CHAR_WIDTH);\n        const splitRegex = new RegExp(`.{1,${maxCharPerRow}}`, \"g\");\n        const splitLabelNameRows = l.name.match(splitRegex);\n        if (splitLabelNameRows.length) {\n          splitLabelNameRows.forEach(splitLabel => {\n            acc.push([{ ...l, name: splitLabel.trim() }]);\n          });\n          return acc;\n        }\n      }\n      if (lastRow(acc)) {\n        // this isn't the first element, check width of last label row\n        const lastRowWidth = calcRowWidth(lastRow(acc));\n        if (lastRowWidth + nameWidth <= 200) {\n          // there's space in the last row for this label as well\n          acc[acc.length - 1].push(l);\n          return acc;\n        }\n      }\n      acc.push([l]); // need to make a new row for this label\n      return acc;\n    }, []);\n\n    // find the grouping's height and width (max row width)\n    const groupHeight = labelRows.length * lineHeight;\n    const groupWidth = labelRows.reduce(\n      (max, row, i) =>\n        Math.max(\n          max,\n          calcRowWidth(row) - (i === labelRows.length - 1 ? CHAR_WIDTH : 0)\n        ), // no comma on last row, correct\n      0\n    );\n    // add one CHAR_WIDTH padding to all sides of label box\n    const [rectHeight, rectWidth] = [groupHeight, groupWidth].map(\n      x => x + 2 * CHAR_WIDTH\n    );\n\n    // generate the line between the name and plasmid surface\n    const forkCoor = group.forkCoor || group.textCoor;\n    const linePath = group.forkCoor\n      ? `M${group.textCoor.x} ${group.textCoor.y} L${forkCoor.x} ${forkCoor.y}`\n      : `M${group.lineCoor.x} ${group.lineCoor.y} L${forkCoor.x} ${forkCoor.y}`;\n\n    // find the upper left coordinate for the group. if this is on the right\n    // side of the plasmid, this is upper left. if it's on the left side of\n    // the plasmid, it should be upper right\n    let { x, y } = group.textCoor;\n    // the +3) is for \",+#\"\n    x =\n      group.textAnchor === \"end\"\n        ? x - (group.labels[0].name.length + 3) * CHAR_WIDTH\n        : x;\n    y -= CHAR_WIDTH;\n    if (Zoom === 0) {\n      x = Math.max(x, 2 * CHAR_WIDTH); // prevent overflow of left or right side\n      x = Math.min(x, width - 2 * CHAR_WIDTH - groupWidth);\n      y = Math.max(y, 2 * CHAR_WIDTH); // prevent overflow of top and bottom\n      y = Math.min(y, height - 2 * CHAR_WIDTH - groupHeight);\n    }\n\n    // add padding to the box by adding/subbing a CHAR_WIDTH from edges\n    const groupCoor = { x, y };\n    const rectCoor = { x: x - CHAR_WIDTH, y: y - CHAR_WIDTH };\n\n    const key = `${group.labels[0].id}_overlay`;\n\n    return (\n      <g key={key} onMouseLeave={() => setHoveredGroup(\"\")}>\n        <path d={linePath} className=\"label-line\" />\n        <rect\n          fill=\"white\"\n          stroke=\"none\"\n          height={rectHeight}\n          width={rectWidth}\n          {...rectCoor}\n        />\n        <text {...groupCoor}>\n          {labelRows.map((r, i) => (\n            // turn each group of label rows into a text span\n            // that's vertically spaced from the row above it\n            // add a comma to all but the last label\n            <tspan\n              key={`${key}_${i}`}\n              y={groupCoor.y + (i + 0.5) * lineHeight}\n              x={groupCoor.x}\n              alignmentBaseline=\"middle\"\n            >\n              {r.map((l, i2) => (\n                // every label should have its own id (used by selection\n                // handler) and trigger the hoverCutSite function\n                // if it's an enzyme\n                <React.Fragment key={l.id}>\n                  <tspan\n                    id={l.id}\n                    className=\"circular-label\"\n                    y={groupCoor.y + (i + 0.5) * lineHeight}\n                    alignmentBaseline=\"middle\"\n                    tabIndex={-1}\n                  >\n                    {l.name}\n                  </tspan>\n                  {i2 < r.length - 1 || i !== labelRows.length - 1 ? \",\" : \"\"}\n                </React.Fragment>\n              ))}\n            </tspan>\n          ))}\n        </text>\n        <rect\n          fill=\"none\"\n          stroke=\"black\"\n          strokeWidth={1.5}\n          height={rectHeight}\n          width={rectWidth}\n          {...rectCoor}\n        />\n      </g>\n    );\n  }\n}\n","import * as React from \"react\";\nimport { CHAR_WIDTH } from \"../Circular\";\nimport \"./Labels.scss\";\nimport WrappedGroupLabel from \"./WrappedGroupLabel\";\n\n/**\n * used to build up all plasmid labels, for annotations, enzymes, etc\n *\n * this should eventually show a name on the annotation if the viewer is\n * sufficiently zoomed, and simply show a line connecting the name\n * to the path if it is too zoomed out and the names do not fit within a path\n *\n * a caveat to take into account here is that the names, outside the\n * map, might also overlap with one another. There will need to be a check, given\n * the dimensions of each name, calculated by the font, and the size\n * of the viewer, for scaling these names and positioning in the Y-direction\n * to avoid this overlap problem\n *\n * @type {Function}\n */\nexport default class Labels extends React.Component {\n  static getDerivedStateFromProps = (nextProps, prevState) => {\n    // I'm storing the name position groups in state because hovering and\n    // leaving a hover both trigger a change in whether to render and show\n    // the annotation block, it would be expensive to regroup labels\n    // on every hover event\n    return { labelGroups: Labels.groupOverlappingLabels(nextProps), hoveredGroup: prevState.hoveredGroup };\n  };\n\n  /**\n   * need to avoid having overlapping names. if names\n   * overlap with one another, they should be grouped together and\n   * just show the first name of the group. Ex: \"M13-rev,GTP,+3\"\n   *\n   * On hover over this group, all the other names should be shown\n   *\n   * this should return all the informaiton needed to render the\n   * name by itself or in a grouping\n   */\n  static groupOverlappingLabels = (props) => {\n    const {\n      radius,\n      labels,\n      center,\n      seqLength,\n      findCoor,\n      lineHeight,\n      size,\n      Zoom,\n      yDiff\n    } = props;\n\n    // create a radius outside the plasmid map for placing the names\n    const textRadiusAdjust =\n      Zoom < 60 && seqLength > 200 ? lineHeight * 2 : lineHeight * 3.5;\n    const textRadius = radius + textRadiusAdjust;\n\n    /**\n     * add positional information to each label. this includes the coordinates\n     * for the textCoor (starting point for text), line (starting point\n     * for the line connecting plasmid to name) and the textAnchor (does the name\n     * get positioned so it starts at the textCoor or ends at the textCoor?)\n     */\n    const labelsWithCoordinates = labels\n      .reduce((acc, labelRow) => acc.concat(labelRow), []) // flatten the rows\n      .map(\n        (a) => {\n          // find the mid-point, vertically, for the label, correcting for entities\n          // that cross the zero-index\n          let annCenter;\n          if (a.type === \"enzyme\") {\n            annCenter = a.start;\n          } else if (a.end > a.start) {\n            const annMidSum = a.end + a.start;\n            annCenter = annMidSum / 2;\n          } else {\n            const annStart = a.start - seqLength;\n            const annMidSum = annStart + a.end;\n            annCenter = annMidSum / 2;\n          }\n\n          // find the seed-points\n          const lineCoor = findCoor(annCenter, radius, true);\n          const textCoor = findCoor(annCenter, textRadius, true);\n          const left = textCoor.x <= center.x;\n\n          // find the textAnchor, based on which side of plasmid it's on\n          const textAnchor = left ? \"end\" : \"start\";\n          const label = a; // just to keep short-hand in return\n          return { label, lineCoor, textCoor, textAnchor };\n        }\n      );\n\n    // a utility function for checking whether a label and textCoor will overflow\n    const groupOverflows = (label, textCoor) => {\n      const nameLength = (label.name.length + 4) * CHAR_WIDTH; // +4 for \",+#\" and padding\n      let overflow = false;\n\n      const heightYPos = textCoor.y + yDiff;\n      if (heightYPos < 0 || heightYPos > size.height) {\n        overflow = true; // vertical overflow\n      } else if (textCoor.x - nameLength < 0 || textCoor.x + nameLength > size.width) {\n        overflow = true; // horizontal overflow\n      }\n      return overflow;\n    };\n\n    /**\n     * merge overlapping names into groupings. If multiple of the labels\n     * will overlap with one another, create an array of them and generate an\n     * overview name to show for all of them (ex above)\n     */\n    let labelsGrouped = labelsWithCoordinates.reduce((acc, n) => {\n      // search through the other names and check whether any would overlap\n      const overlapIndex = acc.findIndex(g => {\n        // first check whether the two labels are on the same side of the plasmid\n        if (g.textAnchor === n.textAnchor) {\n          // characters are 13px high, this is creating 2px of padding\n          return Math.abs(g.textCoor.y - n.textCoor.y) < 15;\n        }\n        return false;\n      });\n\n      if (overlapIndex > -1) {\n        // add this label to an already existing group\n        acc[overlapIndex].labels.push(n.label);\n        acc[overlapIndex].grouped = true;\n        return acc;\n      }\n\n      // this name doesn't overlap with any others\n      // check whether the its name overflows the side of the viewer\n      const overflow = groupOverflows(n.label, n.textCoor);\n\n      // create a new \"group\" from this single label\n      return acc.concat({\n        textAnchor: n.textAnchor,\n        textCoor: n.textCoor,\n        lineCoor: n.lineCoor,\n        labels: [n.label],\n        grouped: overflow,\n        overflow: overflow\n      });\n    }, []);\n\n    /**\n     * we now want to *ungroup* labels that we can do overlap avoidance for by doing small vertical\n     * adjustments. So for every group that is grouped but doesn't overlap (ie, the labels\n     * overlap but the group doesn't overflow the viewer's edge), try to spread out the\n     * labels so the user can see all of them at once and by default\n     *\n     * to do this we need to create a forkCoor, where the textCoors of the constituent\n     * labels will connect. That forkCoor, in turn, will be what connects to the edge of\n     * the plasmid\n     */\n    labelsGrouped = labelsGrouped.reduce((acc, g, i) => {\n      // wasn't grouped or overflows the side of viewer or too many labels to try and help\n      if (!g.grouped || g.overflow || g.labels.length > 4) return acc.concat(g);\n\n      // since the labels are sorted (see circular.filterOutsideLabels), we can just check the\n      // coordinate of this group's neighbors to see whether we can spread out\n      let leftNeighbor = acc[acc.length - 1];\n      let rightNeighbor = labelsGrouped[i + 1];\n      if (leftNeighbor && leftNeighbor.textAnchor !== g.textAnchor) {\n        leftNeighbor = undefined;\n      }\n      if (rightNeighbor && rightNeighbor.textAnchor !== g.textAnchor) {\n        rightNeighbor = undefined;\n      }\n\n      // try and split/shift labels horizontally\n      const newLabels = g.labels.map((l, i2) => {\n        // if on right side of the viewer, shfit rightward\n        let xDelta = i2 * (3 * CHAR_WIDTH);\n        if (g.textAnchor === \"end\") xDelta = -xDelta; // otherwise shift leftward\n\n        let yDelta = (g.labels.length - i2) * -15; // start off by shifting upwards 15px if on top half\n        if (g.textCoor.y > center.y) yDelta = (g.labels.length - i2) * 15; // otherwise shift down\n\n        const newTextCoor = {\n          x: g.textCoor.x + xDelta, // try to make the adjustment to the left/right\n          y: g.textCoor.y + yDelta // try ot make the adjustment to the top/bottom\n        };\n        const overflow = groupOverflows(l, newTextCoor);\n\n        return {\n          ...g,\n          textCoor: newTextCoor,\n          grouped: overflow, // only \"grouped\" (misnomer) if it overlaps\n          overflow: overflow,\n          labels: [l], // single label now\n          forkCoor: g.textCoor // fork point becomes the old textCoor\n        };\n      });\n\n      // check whether any of these attempted new labels overlaps with the neighbors\n      const overlapWithNeighbors = newLabels.some(l =>\n        [leftNeighbor, rightNeighbor].some(\n          n => n && Math.abs(n.textCoor.y - l.textCoor.y) < 15\n        )\n      );\n      if (overlapWithNeighbors) return acc.concat(g); // just bail and return the original grouping\n      return acc.concat(...newLabels); // add the newly created labels\n    }, []);\n\n    /**\n     * give actual names. this is in a separate loop because the group name\n     * is going to indicate how many other sub labels are in a block/grouping\n     * and it's easier to make them once than to update continually in the reduce above\n     */\n    labelsGrouped = labelsGrouped.map(a => {\n      const firstName = a.labels[0].name;\n      const restLength = a.labels.length - 1;\n      if (a.overflow) {\n        // would extend outside the viewer if we included the group name\n        return { ...a, name: `+${restLength + 1}` };\n      } else if (a.grouped) {\n        // does not extend outside width/height of the viewer with group name\n        return { ...a, name: `${firstName},+${restLength}` };\n      }\n      // didn't have to be grouped at all\n      return { ...a, name: firstName };\n    });\n\n    /**\n     * prevent the labels from overflowing the side of the viewer\n     * even the small \"+1\" labels can overflow the sides if the viewer is small enough\n     * this pushes their textCoors inward to prevent that\n     */\n    return labelsGrouped.map(g => {\n      if (Zoom > 0) return g; // this adjustment is only for fully zoomed out state\n\n      let { x, y } = g.textCoor;\n      // prevent the text label from overflowing the sides (w/ one char padding)\n      x = Math.max(CHAR_WIDTH * (g.name.length + 1), x);\n      x = Math.min(size.width - (g.name.length + 1) * CHAR_WIDTH, x);\n      y = Math.max(CHAR_WIDTH, y);\n      y = Math.min(size.height - CHAR_WIDTH - 13, y); // assuming 13px font-size w/ padding\n      return { ...g, textCoor: { x, y } };\n    });\n  };\n\n  // empty arrays on first load\n  state = {\n    labelGroups: [],\n    hoveredGroup: \"\"\n  };\n\n  // set the currently hovered group\n  setHoveredGroup = (hoveredGroup) => {\n    if (hoveredGroup !== this.state.hoveredGroup) {\n      this.setState({ hoveredGroup });\n    }\n  };\n\n  render() {\n    const { labelGroups, hoveredGroup } = this.state;\n\n    // find the currently hovered group\n    const hovered = labelGroups.find(g => g.labels[0].id === hoveredGroup);\n\n    return (\n      <g id=\"circular-labels\" onMouseLeave={() => this.setHoveredGroup(\"\")}>\n        {labelGroups.map(g => {\n          const [first] = g.labels;\n          // generate the line between the name and plasmid surface\n          const fC = g.forkCoor || g.textCoor;\n          const labelLines = (\n            <React.Fragment>\n              <path\n                d={`M${g.lineCoor.x} ${g.lineCoor.y} L${fC.x} ${fC.y}`}\n                className=\"label-line\"\n              />\n              {g.forkCoor && (\n                <path\n                  d={`M${fC.x} ${fC.y} L${g.textCoor.x} ${g.textCoor.y}`}\n                  className=\"label-line\"\n                />\n              )}\n            </React.Fragment>\n          );\n\n          if (!g.grouped) {\n            // just a single name in this position\n            return (\n              <g key={first.id}>\n                {labelLines}\n                <text\n                  id={first.id}\n                  className=\"circular-label\"\n                  {...g.textCoor}\n                  textAnchor={g.textAnchor}\n                  alignmentBaseline=\"middle\"\n                >\n                  {g.name}\n                </text>\n              </g>\n            );\n          } else if (first.id === hoveredGroup) {\n            // return nothing, this group block needs to be rendered last to be\n            // on top of the other elements in the SVG\n            return null;\n          }\n          // a group of names which should render an overlap block\n          return (\n            <g key={`${first.id}_listener`} id={`${first.id}-label`}>\n              {labelLines}\n              <text\n                id={first.id}\n                className=\"circular-label\"\n                textAnchor={g.textAnchor}\n                onMouseEnter={() => this.setHoveredGroup(first.id)}\n                alignmentBaseline=\"middle\"\n                {...g.textCoor}\n              >\n                {g.name}\n              </text>\n            </g>\n          );\n        })}\n        {hovered && (\n          <WrappedGroupLabel\n            group={hovered}\n            size={this.props.size}\n            setHoveredGroup={this.setHoveredGroup}\n            lineHeight={this.props.lineHeight}\n            Zoom={this.props.Zoom}\n          />\n        )}\n      </g>\n    );\n  }\n}\n","import * as React from \"react\";\nimport shortid from \"shortid\";\n\n/**\n * renders the selection range of the plasmid viewer\n * consists of three parts (during an active selection):\n * \t\tleft sidebar, right sidebar and the middle selection region\n *\n * if nothing is selected, it should just be the single cursor\n * without a middle highlighted region\n */\nclass CircularSelection extends React.PureComponent {\n  render() {\n    const {\n      seq,\n      Zoom,\n      radius,\n      lineHeight,\n      seqLength,\n      getRotation,\n      findCoor,\n      generateArc,\n      totalRows,\n      seqSelection: { ref, start, end, clockwise }\n    } = this.props;\n\n    // calculate the length of the current selection region\n    let selLength = 0;\n    // start and end is the same, and something has been selected\n    if (start === end && ref === \"ALL\") {\n      selLength = seqLength;\n    } else if (start > end) {\n      selLength =\n        clockwise !== false\n          ? Math.abs(end - start + seqLength)\n          : -Math.abs(start - end);\n    } else if (start < end) {\n      selLength =\n        clockwise !== false\n          ? Math.abs(end - start)\n          : -Math.abs(start - end + seqLength);\n    }\n\n    // for all cases when the entire circle is selected\n    if (Math.abs(selLength) === seqLength) {\n      const adjust = selLength > 0 ? -0.1 : 0.1;\n      selLength += adjust; // can't make an arc from a full circle\n    }\n\n    // const calc the size of the selection radii\n    let topR = radius + lineHeight; // outer radius\n    if (Zoom > 60 || seq.length < 200) {\n      // at above 60 zoom, two rows of basepairs will be rendered\n      topR += 2 * lineHeight;\n    }\n    const bAdjust = lineHeight * totalRows; // adjust bottom radius\n    const bottomR = radius - bAdjust; // inner radius\n\n    // find start and stop coordinates to created edges\n    const lineTop = findCoor(0, topR);\n    const lineBottom = findCoor(0, bottomR);\n    const edgePath = `M ${lineBottom.x} ${lineBottom.y}\n\t\t\tL ${lineTop.x} ${lineTop.y}`;\n\n    // !== false is needed because it can be undefined\n    const sFlagF = clockwise !== false || ref === \"ALL\" ? 1 : 0; // sweep flag of first arc\n\n    let lArc = false;\n    if (clockwise !== false && selLength > seqLength / 2) {\n      lArc = true;\n    } else if (clockwise === false && Math.abs(selLength) > seqLength / 2) {\n      lArc = true;\n    }\n\n    const selectPath = generateArc({\n      innerRadius: bottomR,\n      outerRadius: topR,\n      length: selLength,\n      largeArc: lArc,\n      sweepFWD: sFlagF\n    });\n\n    // this should be very thin when the selection range starts and ends at same point\n    let edgeStrokeWidth = 3;\n    if (Zoom > 30) {\n      edgeStrokeWidth = 4;\n    }\n    if (start === end) {\n      edgeStrokeWidth = 1.5;\n    }\n\n    const edgeStyle = {\n      fill: \"transparent\",\n      stroke: \"black\",\n      strokeWidth: edgeStrokeWidth,\n      shapeRendering: \"auto\"\n    };\n    const selectStyle = {\n      stroke: \"none\",\n      fill: \"#DEF6FF\",\n      shapeRendering: \"auto\"\n    };\n\n    const firstId = shortid.generate();\n    const secondId = shortid.generate();\n    const thirdId = shortid.generate();\n\n    return (\n      <g id=\"circular-selection\">\n        {selLength && (\n          <path\n            d={selectPath}\n            id={secondId}\n            transform={getRotation(start)}\n            {...selectStyle}\n          />\n        )}\n        <path\n          d={edgePath}\n          id={firstId}\n          transform={getRotation(start)}\n          {...edgeStyle}\n        />\n        {selLength && (\n          <path\n            d={edgePath}\n            id={thirdId}\n            transform={getRotation(end)}\n            {...edgeStyle}\n          />\n        )}\n      </g>\n    );\n  }\n}\n\nexport default CircularSelection;\n","import { debounce } from \"lodash\";\nimport * as React from \"react\";\n\n/**\n * an HOC used one level above the Sequence viewer. It handles the routing of all\n * events, including keypresses, mouse clicks, etc.\n *\n * its other main function is to build the context menu at all times, so that\n * the options available in the context menu are all relevant to whatever has been\n * selected\n *\n * @param  {React.Component} WrappedComp\n * @return {React.Component}\n */\nconst withEventRouter = WrappedComp =>\n  class WithEventRouter extends React.PureComponent {\n    // eslint-disable-next-line\n    static displayName = `EventRouter(${WrappedComp.displayName ||\n      \"Component\"})`;\n\n    /**\n     * Triple click event handler helpers\n     */\n    _delayedClick = null;\n\n    clickedOnce = null;\n\n    clickedTwice = null;\n\n    constructor(props) {\n      super(props);\n\n      this.state = {\n        id: `${props.type}-${props.name.replace(/\\s/g, \"\")}-event-router`\n      };\n    }\n\n    componentDidMount = () => {\n      window.addEventListener(\"keydown\", this.handleKeyPress);\n    };\n\n    componentWillUnmount = () => {\n      window.removeEventListener(\"keydown\", this.handleKeyPress);\n    };\n\n    /** set the event router reference on this class */\n    setEventRouter = eventRouter => {\n      this.eventRouter = eventRouter;\n    };\n\n    suppressBrowserContextMenu = e => {\n      if (!e.shiftKey) {\n        e.preventDefault();\n        this.handleMouseEvent(e);\n      }\n    };\n\n    /**\n     * select all\n     */\n    selectAllHotkey = () => {\n      const {\n        setPartState,\n        seqSelection: { start }\n      } = this.props;\n      setPartState({\n        seqSelection: {\n          start: start,\n          end: start,\n          clockwise: true,\n          ref: \"ALL\" // ref to all means select the whole thing\n        }\n      });\n    };\n\n    handleTripleClick = () => {\n      this.selectAllHotkey();\n    };\n\n    resetClicked = () => {\n      this.clickedOnce = null;\n      this.clickedTwice = null;\n    };\n\n    /**\n     * if the contextMenu button is clicked, check whether it was clicked\n     * over a noteworthy element, for which db mutations have been written.\n     *\n     * if it is, mutate the contextMenu to account for those potential interactions\n     * and pass on the click. Otherwise, do nothing\n     *\n     * if it is a regular click, pass on as normal\n     *\n     * @param  {React.SyntheticEvent} e   the mouse event\n     */\n    handleMouseEvent = e => {\n      const { mouseEvent } = this.props;\n\n      if (e.type === \"mouseup\") {\n        if (!this._delayedClick) {\n          this._delayedClick = debounce(this.resetClicked, 250);\n        }\n        if (this.clickedOnce === e.target && this.clickedTwice === e.target) {\n          this._delayedClick.cancel();\n          this.handleTripleClick();\n          this._delayedClick();\n        } else if (\n          this.clickedOnce === e.target &&\n          this.clickedTwice === null\n        ) {\n          this._delayedClick.cancel();\n          this.clickedOnce = e.target;\n          this.clickedTwice = e.target;\n          this._delayedClick();\n        } else {\n          this._delayedClick.cancel();\n          this.clickedOnce = e.target;\n          this._delayedClick();\n        }\n      }\n      const { type, button, ctrlKey } = e;\n      const ctxMenuClick = type === \"mousedown\" && button === 0 && ctrlKey;\n\n      if (e.button === 0 && !ctxMenuClick) {\n        // it's a mouse drag event or an element was clicked\n        mouseEvent(e);\n      }\n    };\n\n    /**\n     * handle a scroll event and, if it's a CIRCULAR viewer, update the\n     * current central index\n     */\n    handleScrollEvent = e => {\n      const { Linear, circularCentralIndex, seq, setPartState } = this.props;\n\n      if (!Linear) {\n        // a \"large scroll\" (1000) should rotate through 20% of the plasmid\n        let delta = seq.length * (e.deltaY / 5000);\n        delta = Math.floor(delta);\n\n        // must scroll by *some* amount (only matters for very small plasmids)\n        if (delta === 0) {\n          if (e.deltaY > 0) delta = 1;\n          else delta = -1;\n        }\n\n        let newCentralIndex = circularCentralIndex + delta;\n        newCentralIndex = (newCentralIndex + seq.length) % seq.length;\n\n        setPartState({\n          circularCentralIndex: newCentralIndex,\n          findState: { searchResults: [], searchIndex: 0 },\n          showSearch: false\n        });\n      }\n    };\n\n    /**\n     * copy the given range of the linearSequence to the users clipboard\n     * more info @ https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand\n     */\n    clipboardCopy = () => {\n      const {\n        seq,\n        seqSelection: { start, end, ref }\n      } = this.props;\n\n      const formerFocus = document.activeElement;\n      const tempNode = document.createElement(\"textarea\");\n\n      if (ref === \"ALL\") {\n        tempNode.innerText = seq;\n      } else {\n        tempNode.innerText = seq.substring(start, end);\n      }\n\n      if (document.body) {\n        document.body.appendChild(tempNode);\n      }\n\n      tempNode.select();\n      document.execCommand(\"copy\");\n      tempNode.remove();\n\n      if (formerFocus) {\n        formerFocus.focus();\n      }\n    };\n    /**\n     * maps a keypress to an interaction (String)\n     *\n     * @param {React.SyntheticEvent} e   synthetic event input\n     * @return {String} \t\t\t     the action performed, one of:\n     * [\"All\", \"Copy\", \"Up\", \"Right\", \"Down\", \"Left\"]\n     */\n    keypressMap = e => {\n      const { key, shiftKey } = e;\n      switch (key) {\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"ArrowDown\":\n          return shiftKey ? `Shift${key}` : key;\n        default:\n          return null;\n      }\n      // Sample key mappings\n      // const { key, shiftKey, metaKey, ctrlKey } = e;\n      //   switch (key) {\n      //     case \"ArrowLeft\":\n      //     case \"ArrowRight\":\n      //     case \"ArrowUp\":\n      //     case \"ArrowDown\":\n      //       return shiftKey ? `Shift${key}` : key;\n      //     case \"a\":\n      //       if (metaKey || ctrlKey) {\n      //         e.preventDefault();\n      //         return \"SelectAll\";\n      //       }\n      //       return null;\n      //     case \"c\":\n      //       return metaKey || ctrlKey ? \"Copy\" : null;\n      //     case \"Escape\":\n      //       return \"Clear\";\n      //     case \"Enter\":\n      //       return \"ArrowDown\";\n      //     default:\n      //       return null;\n      //   }\n    };\n\n    /**\n     * Respond to any of:\n     * \tAll: cmd + A, select all\n     * \tCopy: cmd + C, copy\n     * \tUp, Right, Down, Left: some directional movement of the cursor\n     *\n     * @param {String} i  \t\t  one of the commands listed above\n     */\n    handleSeqInteraction = async type => {\n      const { seq, Linear } = this.props;\n      const seqLength = seq.length;\n      const {\n        bpsPerBlock = Math.max(Math.floor(seqLength / 20), 1)\n      } = this.props;\n      switch (type) {\n        case \"SelectAll\": {\n          this.selectAllHotkey();\n          break;\n        }\n        case \"Copy\": {\n          this.clipboardCopy();\n          break;\n        }\n        case \"Clear\": {\n          const {\n            seqSelection: selection,\n            showSearch,\n            setPartState\n          } = this.props;\n          const { type: selectionType } = selection;\n\n          if (selectionType === \"FIND\") {\n            if (showSearch) {\n              setPartState({\n                findState: {\n                  searchIndex: 0,\n                  searchResults: []\n                }\n              });\n            } else {\n              setPartState({\n                showSearch: false\n              });\n            }\n          }\n          break;\n        }\n        case \"ArrowUp\":\n        case \"ArrowRight\":\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ShiftArrowUp\":\n        case \"ShiftArrowRight\":\n        case \"ShiftArrowDown\":\n        case \"ShiftArrowLeft\": {\n          const {\n            seqSelection: selection,\n            findState: { searchIndex: currIdx, searchResults },\n            setPartState\n          } = this.props;\n          const { start, end, type: selectionType } = selection;\n          if (selectionType === \"FIND\") {\n            let nextIdx = currIdx;\n            let nextResults = searchResults;\n            if (type === \"ArrowUp\") {\n              nextIdx = currIdx <= 0 ? searchResults.length - 1 : currIdx - 1;\n            } else if (type === \"ArrowDown\") {\n              nextIdx = currIdx >= searchResults.length - 1 ? 0 : currIdx + 1;\n            }\n            const nextSelectStart =\n              nextIdx >= 0 ? searchResults[nextIdx].start : start;\n            const nextSelectEnd =\n              nextIdx >= 0 ? searchResults[nextIdx].end : end;\n            setPartState({\n              findState: {\n                searchIndex: nextIdx,\n                searchResults: nextResults\n              },\n              seqSelection: {\n                start: nextSelectStart,\n                end: nextSelectEnd\n              },\n              linearCentralIndex: nextSelectStart,\n              circularCentralIndex: nextSelectStart\n            });\n            break;\n          }\n          if (Linear) {\n            let { clockwise } = selection;\n            let newPos = end;\n            if (type === \"ArrowUp\" || type === \"ShiftArrowUp\") {\n              // if there are multiple blocks or just one. If one, just inc by one\n              if (seqLength / bpsPerBlock > 1) {\n                newPos -= bpsPerBlock;\n              } else {\n                newPos -= 1;\n              }\n            } else if (type === \"ArrowRight\" || type === \"ShiftArrowRight\") {\n              newPos += 1;\n            } else if (type === \"ArrowDown\" || type === \"ShiftArrowDown\") {\n              // if there are multiple blocks or just one. If one, just inc by one\n              if (seqLength / bpsPerBlock > 1) {\n                newPos += bpsPerBlock;\n              } else {\n                newPos += 1;\n              }\n            } else if (type === \"ArrowLeft\" || type === \"ShiftArrowLeft\") {\n              newPos -= 1;\n            }\n\n            if (newPos <= -1) {\n              newPos = seqLength + newPos;\n            }\n            if (newPos >= seqLength + 1) {\n              newPos -= seqLength;\n            }\n            const selectionLength = Math.abs(start - end);\n            clockwise =\n              selectionLength === 0\n                ? type === \"ArrowRight\" ||\n                  type === \"ShiftArrowRight\" ||\n                  type === \"ArrowDown\" ||\n                  type === \"ShiftArrowDown\"\n                : clockwise;\n            if (newPos !== start && !type.startsWith(\"Shift\")) {\n              setPartState({\n                seqSelection: {\n                  start: newPos,\n                  end: newPos,\n                  clockwise: true,\n                  ref: \"\"\n                }\n              });\n            } else if (type.startsWith(\"Shift\")) {\n              setPartState({\n                seqSelection: {\n                  start: start,\n                  end: newPos,\n                  clockwise: clockwise,\n                  ref: \"\"\n                }\n              });\n            }\n            break;\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n    };\n\n    /**\n     * action handler for a keyboard keypresses.\n     * Mapping logic has been abstracted to keypressMap in ./api/keypressMap.js\n     *\n     * @param  {React.SyntheticEvent} e   keypress\n     */\n    handleKeyPress = e => {\n      const keyType = this.keypressMap(e);\n      if (!keyType) {\n        return; // not recognized key\n      }\n      this.handleSeqInteraction(keyType);\n    };\n\n    /** a reference used only so we can focus on the event router after mounting */\n    eventRouter;\n\n    render() {\n      const { id } = this.state;\n\n      return (\n        <div\n          id={id}\n          className=\"SeqViewer-eventRouter\"\n          onMouseMove={this.handleMouseEvent}\n          onKeyDown={this.handleKeyPress}\n          onWheel={this.handleScrollEvent}\n          role=\"presentation\"\n          ref={ref => {\n            this.eventRouter = ref;\n          }}\n        >\n          <WrappedComp {...this.props} mouseEvent={this.handleMouseEvent} />\n        </div>\n      );\n    }\n  };\n\nexport default WrappedComp => withEventRouter(WrappedComp);\n","import { isEqual } from \"lodash\";\nimport * as React from \"react\";\n\n/**\n * an HOC dedicated to handling range selection for the LinearSeq viewer\n *\n * since range selection is needed for all other functions that affect the\n * underlying sequence data, this is a highest level HOC\n *\n * @param  {React.Component} WrappedComp\n */\nconst withSelectionHandler = WrappedComp =>\n  class extends React.Component {\n    previousBase = null; // previous base cursor is over, used in circular drag select\n\n    forward = null; // directionality of drag (true if clockwise), used in circular drag select\n\n    fullSelectionLength = 0; // full selection length, used in circular drag select\n\n    dragEvent = false; // is the user currently dragging across the surface of the seqViewer? this is tracked on SeqBlocks in particular (onMouseOver), used in circular drag select\n\n    selectionStarted = false; // is there a selection already, used for shift-click catch up\n\n    shiftSelection = false; // was the last selection action a shift click, used for shift-click catch up\n\n    static displayName = `SelectionHandler(${WrappedComp.displayName ||\n      \"Component\"})`;\n\n    /**\n     * used to handle situations where the mouse movement is too fast to register\n     * correct discrete values\n     */\n    timestamp = null;\n\n    lastMouseX = null;\n\n    lastMouseY = null;\n\n    workspace = document.getElementById(\"part-explorer\");\n    /**\n     * an attempt an event rate limiter, since setting the selection range\n     * in the cache is async (was having a problem getting two sets before the first was complete)\n     */\n    allowSetSelection = true;\n\n    /**\n     * a map between the id of child elements and their associated SelectRanges\n     * @type {Object.<string, SelectRange>}\n     */\n    elementIdsToRanges = new Map();\n\n    /**\n     * an array of the elements that currently have a noted selection\n     * @type {Array.string}\n     */\n    mountedBlocks = new Set();\n\n    /**\n     * Double click event handler helpers\n     * Required because React's onDoubleClick hook doesn't work in conjunction\n     * with other mouse event handlers on the same component\n     */\n    _delayedClick = null;\n\n    clickedOnce = null;\n\n    componentDidMount = () => {\n      document.addEventListener(\"mouseup\", this.stopDrag);\n    };\n\n    componentWillUnmount = () => {\n      document.removeEventListener(\"mouseup\", this.stopDrag);\n    };\n\n    /**\n     * return the SelectRange, defined above, of the id of the element\n     * whos id is passed. This was written for a function in the event router\n     * so it would be able to tell what type of context menu to build\n     *\n     * @param {string} elemId   the id of the element being queried against\n     * @return {SelectRange}   the seelction range of the element selected against\n     */\n    getElement = elemId => this.elementIdsToRanges.get(elemId);\n\n    // stop the current drag event from happening\n    stopDrag = () => {\n      this.dragEvent = false;\n    };\n\n    /**\n     * Called at start of drag to make sure checkers are reset to default state\n     */\n    resetCircleDragVars = start => {\n      this.previousBase = start;\n      this.forward = null;\n      this.fullSelectionLength = 0;\n      this.dragEvent = true; // start a drag event\n    };\n\n    /**\n     * Called to check what the length of the selection is in circle drag select\n     */\n    calcSelectionLength = (start, base, clock) => {\n      const { seq } = this.props;\n      if (base < start && !clock) {\n        return start - base;\n      }\n      if (base > start && !clock) {\n        return start + (seq.length - base);\n      }\n      if (base > start && clock) {\n        return base - start;\n      }\n      if (base < start && clock) {\n        return seq.length - start + base;\n      }\n      return 0;\n    };\n\n    /**\n     * in a linear sequence viewer, given the bounding box of a component, the basepairs\n     * by SeqBlock and the position of the mouse event, find the current base\n     *\n     * @param {SyntheticMouseEvent} e      the click of onMouseOver event\n     * @param {SelectRange} knownRange     a range of a known element\n     * @return {Number}\t\t   the current base being clicked or hovered\n     */\n    calculateBaseLinear = (e, knownRange) => {\n      const { size, bpsPerBlock } = this.props;\n\n      const block = e.currentTarget.getBoundingClientRect();\n      const distFromLeft = e.clientX - block.left;\n      const percFromLeft = distFromLeft / size.width;\n      const bpsFromLeft = Math.round(percFromLeft * bpsPerBlock);\n\n      const currBase = knownRange.start + bpsFromLeft;\n\n      return currBase;\n    };\n\n    /**\n     * in a circular plasmid viewer, given the center of the viewer, and position of the\n     * mouse event, find the currently hovered or clicked basepair\n     *\n     * @param {SyntheticMouseEvent} e    the click of onMouseMove event\n     * @return {Number}   \t\t\t\t the current base being clicked or hovered\n     */\n    calculateBaseCircular = e => {\n      const {\n        center,\n        seq,\n        yDiff,\n        circularCentralIndex: centralIndex\n      } = this.props;\n      if (!center) return 0;\n      const block = e.currentTarget.getBoundingClientRect();\n\n      // position on the plasmid viewer\n      const distFromLeft = e.clientX - block.left;\n      const distFromTop = e.clientY - block.top;\n\n      // position relative to center\n      const x = distFromLeft - center.x;\n      const y = distFromTop - (center.y + yDiff);\n\n      const riseToRun = y / x;\n      const posInRads = Math.atan(riseToRun);\n      let posInDeg = posInRads * (180 / Math.PI) + 90; // convert and shift to vertical is 0\n      if (x < 0) posInDeg += 180; // left half of the viewer\n      const posInPerc = posInDeg / 360; // position as a percentage\n\n      let currBase = Math.round(seq.length * posInPerc); // account for rotation of the viewer\n      currBase += centralIndex;\n      if (currBase > seq.length) currBase -= seq.length;\n      return currBase;\n    };\n\n    /**\n     * add the newly mounted block, by id, to the list\n     * @param  {string} ref  id of the newly mounted SeqBlock\n     */\n    addMountedBlock = ref => {\n      this.mountedBlocks.add(ref);\n    };\n\n    /**\n     * remove the id of the passed element from the list of tracked refs\n     * @param  {string} ref  if of the element to drop from list\n     */\n    removeMountedBlock = ref => {\n      this.mountedBlocks.delete(ref);\n      this.elementIdsToRanges.delete(ref);\n    };\n\n    /**\n     * a ref callback for setting adding the id of child to its SelectRange\n     * it stores the id of all select elements, which will be updated when the select range\n     * changes (as opposed to updating the whole tree)\n     * @param  {string} ref          \t\telement id, as it appears in DOM\n     * @param  {SelectRange} selectRange   \tdef above\n     */\n    mapIdToRange = (ref, selectRange) => {\n      if (selectRange.type === \"SELECT\") {\n        this.mountedBlocks.add(ref);\n      }\n      this.elementIdsToRanges.set(ref, { ref, ...selectRange });\n    };\n\n    /** set the selection for the current part */\n    setSequenceSelection = selectRange => {\n      const {\n        seqSelection,\n        setPartState,\n        findState: { searchIndex }\n      } = this.props;\n      const {\n        clockwise = true,\n        start = 0,\n        end = 0,\n        ref = \"\",\n        type = \"\",\n        searchIndex: newSearchIndex = null\n      } = selectRange;\n      const newSelection = {\n        type,\n        ref,\n        clockwise,\n        start,\n        end\n      };\n      const findStateIndex =\n        newSearchIndex === null ? searchIndex : newSearchIndex;\n      if (!isEqual(seqSelection, newSelection)) {\n        setPartState({\n          seqSelection: newSelection,\n          findState: { searchIndex: findStateIndex }\n        });\n\n        if (this.workspace) {\n          this.workspace.focus();\n        }\n      }\n    };\n\n    /**\n     * updateSelectionWithknownRange\n     *\n     * the selected child element is something that is known by reference.\n     * update its SeqBlock's range (or any others affected) with the newly\n     * active range\n     *\n     * @param {React.SyntheticEvent} e  \t\tthe mouseEvent\n     */\n    updateSelectionWithknownRange = e => {\n      const {\n        seq,\n        Linear,\n        findState: { searchResults },\n        setPartState\n      } = this.props;\n\n      if (!this.allowSetSelection) return;\n      // should not be updating selection since it's not a drag event time\n      if ((e.type === \"mousemove\" || e.type === \"mouseup\") && !this.dragEvent) {\n        return;\n      }\n\n      const knownRange = this.dragEvent\n        ? this.elementIdsToRanges.get(e.currentTarget.id) // only look for SeqBlocks\n        : this.elementIdsToRanges.get(e.target.id) || // elements and SeqBlocks\n          this.elementIdsToRanges.get(e.currentTarget.id);\n      if (!knownRange) return; // there isn't a known range with the id of the element\n      // clicked (this shouldn't happen)\n\n      const { start, end, direction } = knownRange;\n      switch (knownRange.type) {\n        case \"ANNOTATION\":\n        case \"FIND\": {\n          // Annotation or find selection range\n          const clockwise = !(knownRange.direction && direction === \"REVERSE\");\n          const selectionStart = clockwise ? start : end;\n          const selectionEnd = clockwise ? end : start;\n          const newSearchIndex = searchResults.findIndex(\n            res => res.start === selectionStart\n          );\n          this.setSequenceSelection({\n            ...knownRange,\n            start: selectionStart,\n            end: selectionEnd,\n            clockwise: clockwise,\n            searchIndex: newSearchIndex\n          });\n          this.dragEvent = false;\n\n          if (!Linear && knownRange.type === \"ANNOTATION\") {\n            setPartState({\n              circularCentralIndex: knownRange.start || 0\n            });\n          }\n          break;\n        }\n        case \"SEQ\": {\n          // SeqBlock or anything on Circular (not already described above)\n          let currBase = null;\n          const { seqSelection: currSelection } = this.props;\n          if (Linear) {\n            currBase = this.calculateBaseLinear(e, knownRange);\n            const clockwiseDrag =\n              currSelection &&\n              currSelection.start !== null &&\n              currBase >= currSelection.start;\n            if (e.type === \"mousedown\" && currBase !== null) {\n              // this is the start of a drag event\n              this.setSequenceSelection({\n                start: e.shiftKey ? currSelection.start : currBase,\n                end: currBase,\n                clockwise: clockwiseDrag\n              });\n              this.dragEvent = true;\n            } else if (this.dragEvent && currBase !== null) {\n              // continue a drag event that's currently happening\n              this.setSequenceSelection({\n                ...currSelection,\n                end: currBase,\n                clockwise: clockwiseDrag\n              });\n            }\n          } else if (!Linear) {\n            let {\n              start: newStart,\n              end: newEnd,\n              ref: newRef,\n              clockwise: newClockwise\n            } = currSelection;\n            const seqLength = seq.length;\n            currBase = this.calculateBaseCircular(e); // get the base currently hovered over\n            if (e.type === \"mousedown\") {\n              if (e.shiftKey) {\n                this.shiftSelection = true;\n              }\n              const selStart = e.shiftKey ? currSelection.start : currBase;\n              let forward = currSelection.clockwise;\n              const lookaheadc = this.calcSelectionLength(\n                selStart,\n                currBase,\n                true\n              ); // check clockwise selection length\n              if (!this.selectionStarted) {\n                const lookaheadcc = this.calcSelectionLength(\n                  selStart,\n                  currBase,\n                  false\n                ); // check counterclockwise selection length\n                forward = lookaheadc < lookaheadcc; // initial selection direction is whichever creates the smaller selection\n              }\n              this.selectionStarted = lookaheadc > 0; // update check for whether there is a prior selection\n              this.resetCircleDragVars(selStart); // begin drag event\n              newStart = selStart;\n              newEnd = currBase;\n              newClockwise = forward; // default to whatever would create the smaller selection\n              newRef = \"\"; // this is needed to reset selection refs we have from previous selections\n            } else if (\n              e.type === \"mousemove\" &&\n              this.dragEvent &&\n              typeof currBase === \"number\" // this is necessary because 0 is falsey\n            ) {\n              if (currBase !== this.previousBase) {\n                const increased = currBase > this.previousBase; // bases increased\n                const changeThreshold = seqLength * 0.9; // threshold for unrealistic change by mouse movement\n                const change = Math.abs(this.previousBase - currBase); // index change from this mouse movement\n                const crossedZero = change > changeThreshold; // zero was crossed if base jumped more than changeThreshold\n                this.forward = increased ? !crossedZero : crossedZero; // bases increased XOR crossed zero\n                const lengthChange = crossedZero ? seqLength - change : change; // the change at the point where we cross zero has to be normalized by seqLength\n                let sameDirectionMove =\n                  this.forward === currSelection.clockwise ||\n                  currSelection.clockwise === null; // moving in same direction as start of drag or start of drag\n                this.fullSelectionLength = sameDirectionMove\n                  ? this.fullSelectionLength + lengthChange\n                  : this.fullSelectionLength - lengthChange; // cumulatively keep track of selection length\n                this.previousBase = currBase; // done comparing with previous base, update previous base\n                if (\n                  this.fullSelectionLength < seqLength * 0.01 &&\n                  !this.shiftSelection\n                ) {\n                  let clockwise = this.forward; // near selection start so selection direction is up for grabs\n                  const check = this.calcSelectionLength(\n                    currSelection.start,\n                    currBase,\n                    this.forward\n                  ); // check actual current selection length\n                  if (this.fullSelectionLength < 0) {\n                    this.fullSelectionLength = check; // This is to correct for errors when dragging too fast\n                  }\n                  if (check > this.fullSelectionLength) {\n                    clockwise = !this.forward; // the actual selection length being greater than additive selection length means we have come back to start and want to go in opposite direction\n                  }\n                  newEnd = currBase;\n                  newClockwise = clockwise; // this should be the only time we set the selection direction, all other changes in directionality are change in drag direction\n                  newRef = \"\";\n                }\n                sameDirectionMove = this.forward === currSelection.clockwise; // recalculate this in case we've switched selection directionality\n                const check = this.calcSelectionLength(\n                  currSelection.start,\n                  currBase,\n                  currSelection.clockwise\n                ); // check the selection length, this is agnostic to the ALL reference and will always calculate from where you cursor is to the start of selection\n                if (\n                  this.selectionStarted &&\n                  this.shiftSelection &&\n                  check > this.fullSelectionLength\n                ) {\n                  this.fullSelectionLength = check; // shift select catch up\n                }\n                const sameDirectionDrag = this.dragEvent && sameDirectionMove; // there is an ongoing drag in the same direction as the direction the selection started in\n                const alreadyFullSelection = currSelection.ref === \"ALL\"; // selection is full sequence\n                const hitFullSelection =\n                  !alreadyFullSelection &&\n                  this.fullSelectionLength >= seqLength; // selection became full sequence\n                if (sameDirectionDrag && hitFullSelection) {\n                  newRef = \"ALL\"; // intial set of ALL selection on selection full sequence\n                  newEnd = currSelection.start;\n                } else if (alreadyFullSelection) {\n                  this.fullSelectionLength =\n                    seqLength + (this.fullSelectionLength % seqLength); // this ensures that backtracking doesn't require making up to your overshoot forward circles\n                  if (\n                    !sameDirectionDrag && // changed direction\n                    check === this.fullSelectionLength - seqLength && // back tracking\n                    check > seqLength * 0.9 // passed selection start\n                  ) {\n                    newEnd = currBase; // start decreasing selection size due to backtracking\n                    newRef = \"\";\n                    this.fullSelectionLength =\n                      this.fullSelectionLength - seqLength; // reset calculated additive selection length to normal now that we are not at ALL length\n                  }\n                } else {\n                  newEnd = currBase; // nothing special just update the selection\n                  newRef = \"\";\n                }\n                this.shiftSelection = false;\n              }\n            }\n            this.setSequenceSelection({\n              start: newStart,\n              end: newEnd,\n              ref: newRef,\n              clockwise: newClockwise\n            });\n          }\n          break;\n        }\n        default:\n      }\n    };\n\n    resetClicked = () => {\n      this.clickedOnce = null;\n    };\n\n    render() {\n      return (\n        <WrappedComp\n          {...this.props}\n          getElement={this.getElement}\n          mouseEvent={this.updateSelectionWithknownRange}\n          inputRef={this.mapIdToRange}\n          onUnMount={this.removeMountedBlock}\n        />\n      );\n    }\n  };\n\nexport default WrappedComp => withSelectionHandler(WrappedComp);\n","import withEventRouter from \"./eventRouter\";\nimport withSelectionHandler from \"./selectionHandler\";\n\n/**\n * sequentially apply all the Sequence Viewer HOCs\n *\n * this is just merging the HOCs into a single function to simplfy appling\n * them to the Circular and Linear viewers (one function rather than 4 (or however many there are))\n */\nexport default WrappedViewer =>\n  withSelectionHandler(withEventRouter(WrappedViewer));\n","import * as React from \"react\";\nimport shortid from \"shortid\";\nimport { stackElements } from \"../partElementsToRows\";\nimport Annotations from \"./Annotations/Annotations\";\nimport \"./Circular.scss\";\nimport CircularFind from \"./CircularFind/CircularFind\";\nimport Index from \"./Index/Index\";\nimport Labels from \"./Labels/Labels\";\nimport Selection from \"./Selection/Selection\";\nimport withViewerHOCs from \"../handlers\";\n\n// this will need to change whenever the css of the plasmid viewer text changes\n// just divide the width of some rectangular text by it's number of characters\nexport const CHAR_WIDTH = 7.801;\n\nclass Circular extends React.PureComponent {\n  static getDerivedStateFromProps = nextProps => {\n    /**\n     * given the incoming zoom property, calculate the \"lineHeight\", which is\n     * the height of each row (used as a differential in radius usually)\n     */\n    const calcLineHeight = Zoom => Math.max((Zoom / 100.0) * 3, 1) * 14;\n    const lineHeight = calcLineHeight(nextProps.Zoom);\n    const annotationsInRows = stackElements(\n      nextProps.annotations.filter(ann => ann.type !== \"insert\"),\n      nextProps.seq.length\n    );\n\n    /**\n     * find the element labels that need to be rendered outside the plasmid. This is done for\n     * annotation names/etc for element titles that don't fit within the width of the element\n     * they represent. For example, an annotation might be named \"Transcription Factor XYZ\"\n     * but be only 20bps long on a plasmid that's 20k bps. Obviously that name doesn't fit.\n     * But, a gene that's 15k on the same plasmid shouldn't have it's label outside the plasmid\n     * when it can easily fit on top of the annotation itself\n     */\n    const seqLength = nextProps.seq.length;\n    const { radius } = nextProps;\n    let innerRadius = radius - 3 * lineHeight;\n    const inlinedLabels = [];\n    const outerLabels = [];\n    annotationsInRows.forEach(r => {\n      const circumf = innerRadius * Math.PI;\n      r.forEach(ann => {\n        // how large is the name of the annotation horizontally (with two char padding)\n        const annNameLengthPixels = (ann.name.length + 2) * CHAR_WIDTH;\n        // how large would part be if it were wrapped around the plasmid\n        let annLengthBases = ann.end - ann.start;\n        if (ann.start >= ann.end) annLengthBases += seqLength; // crosses zero-index\n        const annLengthPixels = 2 * circumf * (annLengthBases / seqLength);\n        if (annNameLengthPixels < annLengthPixels) {\n          inlinedLabels.push(ann.id);\n        } else {\n          const { id, name, start, end } = ann;\n          const type = \"annotation\";\n          outerLabels.push({ id, name, start, end, type });\n        }\n      });\n      innerRadius -= lineHeight;\n    });\n\n    // sort all the labels so they're in ascending order\n    outerLabels.sort(\n      (a, b) => Math.min(a.start, a.end) - Math.min(b.start, b.end)\n    );\n\n    return {\n      seqLength: nextProps.seq.length,\n      lineHeight: lineHeight,\n      annotationsInRows: annotationsInRows,\n      inlinedLabels: inlinedLabels,\n      outerLabels: outerLabels\n    };\n  };\n\n  // null arrays on initial load\n  state = {\n    seqLength: 0,\n    lineHeight: 0,\n    annotationsInRows: [],\n    inlinedLabels: [],\n    outerLabels: []\n  };\n\n  /**\n   * find the rotation transformation needed to put a child element in the\n   * correct location around the plasmid\n   *\n   * this func makes use of the centralIndex field in parent state\n   * to rotate the plasmid viewer\n   *\n   * @return {Coor}\n   */\n\n  getRotation = index => {\n    const { center, circularCentralIndex: centralIndex } = this.props;\n    const { seqLength } = this.state;\n    // how many degrees should it be rotated?\n    const adjustedIndex = index - centralIndex;\n    const startPerc = adjustedIndex / seqLength;\n    const degrees = startPerc * 360;\n\n    return `rotate(${degrees || 0}, ${center.x}, ${center.y})`;\n  };\n\n  /**\n   * given an index along the plasmid and its radius, find the coordinate\n   * will be used in many of the child components\n   *\n   * in general this is for lines and labels\n   *\n   * @param {boolean} rotate\tshould the central index be taken into account\n   * \t\t\t\t\t\t\twhen calculating the current coordinate?\n   * @return {Coor}\n   */\n  findCoor = (index, radius, rotate = false) => {\n    const { center, circularCentralIndex, hideHeader } = this.props;\n    const { seqLength } = this.state;\n\n    const rotatedIndex =\n      rotate && !hideHeader ? index - circularCentralIndex : index;\n    const lengthPerc = rotatedIndex / seqLength;\n    const lengthPercCentered = lengthPerc - 0.25;\n    const radians = lengthPercCentered * Math.PI * 2;\n\n    const xAdjust = Math.cos(radians) * radius;\n    const yAdjust = Math.sin(radians) * radius;\n\n    return {\n      x: center.x + xAdjust,\n      y: center.y + yAdjust\n    };\n  };\n\n  /**\n   * given a coordinate, and the degrees to rotate it, find the new coordinate\n   * (assuming that the rotation is around the center)\n   *\n   * in general this is for text and arcs\n   *\n   * @return {Coor}\n   */\n  rotateCoor = (coor, degrees) => {\n    const { center } = this.props;\n\n    // find coordinate's current angle\n    const angle = degrees * 0.0174533; // degrees to radians\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n\n    // find the new coordinate\n    const xDiff = coor.x - center.x;\n    const yDiff = coor.y - center.y;\n    const cosX = cos * xDiff;\n    const cosY = cos * yDiff;\n    const sinX = sin * xDiff;\n    const sinY = sin * yDiff;\n    const xAdjust = cosX - sinY;\n    const yAdjust = sinX + cosY;\n\n    return {\n      x: center.x + xAdjust,\n      y: center.y + yAdjust\n    };\n  };\n\n  /**\n   * given an inner and outer radius, and the length of the element, return the\n   * path for an arc that circles the plasmid. the optional paramters sweepFWD and sweepREV\n   * are needed for selection arcs (where the direction of the arc isn't known beforehand)\n   * and arrowFWD and arrowREV are needed for annotations, where there may be directionality\n   *\n   * @return {string}\n   */\n  generateArc = ({\n    innerRadius,\n    outerRadius,\n    length,\n    largeArc, // see svg.arc large-arc-flag\n    sweepFWD = false,\n    arrowFWD = false,\n    arrowREV = false,\n    offset = 0,\n    isInsert = false\n  }) => {\n    const { radius } = this.props;\n    const { seqLength, lineHeight } = this.state;\n    // build up the six default coordinates\n    let leftBottom = this.findCoor(offset, innerRadius);\n    let leftTop = this.findCoor(offset, outerRadius);\n    let rightBottom = this.findCoor(length + offset, innerRadius);\n    let rightTop = this.findCoor(length + offset, outerRadius);\n    let leftArrow = \"\";\n    let rightArrow = \"\";\n\n    // create arrows by making a midpoint along edge and shifting corners inwards\n    if (arrowREV || arrowFWD) {\n      // one quarter of lineHeight in px is the shift inward for arrows\n      const inwardShift = lineHeight / 4;\n      // given the arc length (inwardShift) and the radius (from SeqViewer),\n      // we can find the degrees to rotate the corners\n      const centralAngle = inwardShift / radius;\n      // Math.min here is to make sure the arrow it's larger than the element\n      const centralAnglePerc = Math.min(centralAngle / 2, length / seqLength);\n      const centralAngleDeg = centralAnglePerc * 360;\n\n      if (arrowREV) {\n        leftBottom = this.rotateCoor(leftBottom, centralAngleDeg);\n        leftTop = this.rotateCoor(leftTop, centralAngleDeg);\n        const lArrowC = this.findCoor(0, (innerRadius + outerRadius) / 2);\n        leftArrow = `L ${lArrowC.x} ${lArrowC.y}`;\n      } else {\n        rightBottom = this.rotateCoor(rightBottom, -centralAngleDeg);\n        rightTop = this.rotateCoor(rightTop, -centralAngleDeg);\n        const rArrowC = this.findCoor(length, (innerRadius + outerRadius) / 2);\n        rightArrow = `L ${rArrowC.x} ${rArrowC.y}`;\n      }\n    }\n\n    const lArc = largeArc ? 1 : 0;\n    const sFlagF = sweepFWD ? 1 : 0;\n    const sFlagR = sweepFWD ? 0 : 1;\n\n    return `M ${rightBottom.x} ${rightBottom.y}\n      A ${innerRadius} ${innerRadius}, 0, ${lArc}, ${sFlagR}, ${leftBottom.x} ${\n      leftBottom.y\n    }\n      L ${leftBottom.x} ${leftBottom.y}\n      ${leftArrow}\n      L ${leftTop.x} ${leftTop.y}\n      A ${outerRadius} ${outerRadius}, 0, ${lArc}, ${sFlagF}, ${rightTop.x} ${\n      rightTop.y\n    }\n      ${rightArrow}\n      Z`;\n  };\n\n  render() {\n    const {\n      Annotations: showAnnotations,\n      Axis: showAxis,\n      Zoom,\n      name,\n      inputRef,\n      mouseEvent,\n      onUnMount,\n      center,\n      radius,\n      yDiff,\n      resizing,\n      size,\n\n      seq,\n      compSeq,\n\n      showSearch,\n      seqSelection,\n      findState,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    } = this.props;\n\n    const partState = {\n      showSearch,\n      seqSelection,\n      findState,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    };\n\n    const {\n      seqLength,\n      lineHeight,\n      annotationsInRows,\n      inlinedLabels,\n      outerLabels\n    } = this.state;\n\n    const { getRotation, generateArc, findCoor, rotateCoor } = this;\n\n    // general values/functions used in many/all children\n    const general = {\n      Zoom,\n      radius,\n      center,\n      lineHeight,\n      seqLength,\n      findCoor,\n      getRotation,\n      generateArc,\n      rotateCoor,\n      inputRef,\n      resizing,\n      ...partState\n    };\n\n    // adjust lineHeight so everything will fit at max zoom\n    // eq of a line between (0, lineHeight), (100, height / totalRows)\n    let vAdjust = 0;\n\n    const plasmidId = `${name}-viewer-circular`;\n    const selectionId = shortid.generate();\n    if (size.height <= 0) return null;\n\n    return (\n      <svg\n        id={plasmidId}\n        className=\"circular-viewer\"\n        onMouseDown={mouseEvent}\n        onMouseUp={mouseEvent}\n        onMouseMove={mouseEvent}\n        ref={inputRef(plasmidId, { type: \"SEQ\" })}\n        {...size}\n      >\n        <g id=\"circular-root\" transform={`translate(0, ${yDiff + vAdjust})`}>\n          <Selection\n            {...general}\n            id={selectionId}\n            onUnmount={onUnMount}\n            totalRows={4}\n            seq={seq}\n          />\n          {showAxis && (\n            <Index\n              {...general}\n              name={name}\n              size={size}\n              yDiff={yDiff + vAdjust}\n              seq={seq}\n              compSeq={compSeq}\n              totalRows={4}\n            />\n          )}\n          <CircularFind {...general} selectionRows={4} />\n          {showAnnotations && (\n            <Annotations\n              {...general}\n              annotations={annotationsInRows}\n              size={size}\n              rowsToSkip={0}\n              inlinedAnnotations={inlinedLabels}\n            />\n          )}\n          {!resizing && (\n            <Labels\n              {...general}\n              labels={outerLabels}\n              size={size}\n              yDiff={yDiff + vAdjust}\n            />\n          )}\n        </g>\n      </svg>\n    );\n  }\n}\n\nexport default withViewerHOCs(Circular);\n","import { isEqual } from \"lodash\";\nimport * as React from \"react\";\n\n/**\n * A wrapper around the seqBlocks. Renders only the seqBlocks that are\n * within the range of the current dom viewerport\n *\n * This component should sense scroll events and, during one, recheck which\n * seqBlocks should currently be shown\n */\nexport default class InfiniteScroll extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      visibleBlocks: []\n    };\n    this.scroller = React.createRef();\n    this.insideDOM = React.createRef();\n  }\n\n  componentDidMount = () => {\n    this.handleScrollOrResize(); // ref should now be set\n    window.addEventListener(\"resize\", this.handleScrollOrResize);\n  };\n\n  componentDidUpdate = (prevProps, prevState, snapshot) => {\n    if (!this.scroller) {\n      // scroller not mounted yet\n      return;\n    }\n\n    const { seqBlocks, size } = this.props;\n    const { visibleBlocks } = this.state;\n\n    if (\n      prevProps.seqBlocks[0].props.linearCentralIndex !==\n      seqBlocks[0].props.linearCentralIndex\n    ) {\n      this.scrollToCentralIndex();\n    } else if (\n      !isEqual(prevProps.size, size) ||\n      seqBlocks.length !== prevProps.seqBlocks.length\n    ) {\n      this.handleScrollOrResize(); // reset\n    } else if (isEqual(prevState.visibleBlocks, visibleBlocks)) {\n      this.restoreSnapshot(snapshot); // something, like ORFs or index view, has changed\n    }\n  };\n\n  componentWillUnmount = () => {\n    window.removeEventListener(\"resize\", this.handleScrollOrResize);\n  };\n\n  /**\n   * more info at: https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate\n   */\n  getSnapshotBeforeUpdate = prevProps => {\n    // find the current top block\n    const distFromTop = this.scroller ? this.scroller.current.scrollTop : 0;\n    // find out 1) which block this is at the edge of the top\n    // and 2) how far from the top of that block we are right now\n    const { blockHeights } = prevProps;\n    let blockIndex = 0;\n    let accumulatedY = 0;\n    do {\n      accumulatedY += blockHeights[blockIndex];\n      blockIndex += 1;\n    } while (\n      accumulatedY + blockHeights[blockIndex] < distFromTop &&\n      blockIndex < blockHeights.length\n    );\n\n    const blockY = distFromTop - accumulatedY; // last extra distance\n    return { blockY, blockIndex };\n  };\n\n  /**\n   * Scroll to centralIndex\n   */\n  scrollToCentralIndex = () => {\n    const {\n      seqBlocks,\n      blockHeights,\n      totalHeight,\n      size: { height }\n    } = this.props;\n    const { visibleBlocks } = this.state;\n    const { clientHeight, scrollHeight } = this.scroller.current;\n\n    // find the first block that contains the new central index\n    const centerBlockIndex = seqBlocks.findIndex(\n      block =>\n        block.props.firstBase <= block.props.linearCentralIndex &&\n        block.props.firstBase + block.props.bpsPerBlock >=\n          block.props.linearCentralIndex\n    );\n\n    // build up the list of blocks that are visible just beneath this first block\n    let newVisibleBlocks = [];\n    if (scrollHeight <= clientHeight) {\n      newVisibleBlocks = visibleBlocks;\n    } else if (centerBlockIndex > -1) {\n      const centerBlock = seqBlocks[centerBlockIndex];\n\n      // create some padding above the new center block\n      const topAdjust =\n        centerBlockIndex > 0 ? blockHeights[centerBlockIndex - 1] : 0;\n      let top = centerBlock.props.y - topAdjust;\n      let bottom = top + height;\n      if (bottom > totalHeight) {\n        bottom = totalHeight;\n        top = totalHeight - height;\n      }\n      blockHeights.reduce((total, h, i) => {\n        if (total >= top && total <= bottom) {\n          newVisibleBlocks.push(i);\n        }\n        return total + h;\n      }, 0);\n\n      // Don't scroll exactly to centralIndex because most of the time\n      // item of interest is at centralIndex and if this is at the top\n      // it can be obscured by things like the search box\n      this.scroller.current.scrollTop =\n        centerBlock.props.y - blockHeights[0] / 2;\n    }\n\n    if (!isEqual(newVisibleBlocks, visibleBlocks)) {\n      this.setState({ visibleBlocks: newVisibleBlocks });\n    }\n  };\n\n  /**\n   * the component has mounted to the DOM or updated, and the window should be scrolled downwards\n   * so that the central index is visible\n   */\n  restoreSnapshot = snapshot => {\n    const { blockHeights } = this.props;\n    const { blockIndex, blockY } = snapshot;\n\n    const scrollTop =\n      blockHeights.slice(0, blockIndex).reduce((acc, h) => acc + h, 0) + blockY;\n\n    this.scroller.current.scrollTop = scrollTop;\n  };\n\n  /**\n   * check whether the blocks that should be visible have changed from what's in state,\n   * update if so\n   */\n  handleScrollOrResize = () => {\n    const {\n      blockHeights,\n      size: { height },\n      totalHeight\n    } = this.props;\n    const { visibleBlocks } = this.state;\n\n    const newVisibleBlocks = [];\n    let { top } = this.insideDOM.current.getBoundingClientRect();\n    top = -top + 35;\n    top = Math.max(0, top); // don't go too high\n    top = Math.min(totalHeight - height, top); // don't go too low\n    const bottom = top + height;\n    top -= 2 * blockHeights[0]; // add two blocks padding on top\n    blockHeights.reduce((total, h, i) => {\n      if (total >= top && total <= bottom) {\n        newVisibleBlocks.push(i);\n      }\n      return total + h;\n    }, 0);\n\n    if (!isEqual(newVisibleBlocks, visibleBlocks)) {\n      this.setState({ visibleBlocks: newVisibleBlocks });\n    }\n  };\n\n  incrementScroller = incAmount => {\n    this.stopIncrementingScroller();\n    this.timeoutID = setTimeout(() => {\n      this.scroller.current.scrollTop += incAmount;\n      this.incrementScroller(incAmount);\n    }, 100);\n  };\n\n  stopIncrementingScroller = () => {\n    if (this.timeoutID) {\n      clearTimeout(this.timeoutID);\n      this.timeoutID = null;\n    }\n  };\n\n  /**\n   * handleMouseOver is for detecting when the user is performing a drag event\n   * at the very top or the very bottom of DIV. If they are, this starts\n   * a recursive incrementation of the DIV's scrollTop (ie an upward or downward scroll\n   * event), that's only terminated by the user leaving the scroll area\n   *\n   * also the rate of the scrollTop is proportional to how far from the top or the\n   * bottom the user is (within [-40, 0] for top, and [0, 40] for bottom)\n   */\n  handleMouseOver = e => {\n    // not relevant, some other type of event, not a selection drag\n    if (e.buttons !== 1) {\n      if (this.timeoutID) {\n        this.stopIncrementingScroller();\n      }\n      return;\n    }\n\n    // check whether the current drag position is near the bottom or the\n    // top of the viewer and, if it is, try and increment the current\n    // centralIndex (triggering a downward scroll event)\n    const scrollerBlock = this.scroller.current.getBoundingClientRect();\n    let percFromTop = (e.clientY - scrollerBlock.top) / scrollerBlock.height;\n    if (percFromTop > 0.95) {\n      percFromTop = Math.min(1, percFromTop);\n      let scaledPerc = percFromTop - 0.95; // [0.0, 0.05]\n      scaledPerc *= 20; // [0, 1]\n      const scaledScroll = 40 * scaledPerc; // [0, 40]\n      this.incrementScroller(scaledScroll);\n    } else if (percFromTop < 0.05) {\n      percFromTop = 0.05 - Math.max(0, percFromTop);\n      const scaledPerc = 20 * percFromTop; // [0, 1]\n      const scaledScroll = -40 * scaledPerc; // [-40, 0]\n      this.incrementScroller(scaledScroll);\n    } else {\n      this.stopIncrementingScroller();\n    }\n  };\n\n  /** ref to a div that's for scrolling: https://flow.org/en/docs/react/types/ */\n  scroller;\n\n  insideDOM;\n\n  timeoutID;\n\n  render() {\n    const {\n      seqBlocks,\n      blockHeights,\n      totalHeight: height,\n      size: { width }\n    } = this.props;\n    const { visibleBlocks } = this.state;\n\n    // find the height of the empty div needed to correctly position the rest\n    const [firstRendered] = visibleBlocks;\n    const spaceAbove = blockHeights\n      .slice(0, firstRendered)\n      .reduce((acc, h) => acc + h, 0);\n\n    return (\n      <div\n        id=\"Linear-scroller\"\n        ref={this.scroller}\n        className=\"scroll\"\n        onScroll={this.handleScrollOrResize}\n        onMouseOver={this.handleMouseOver}\n        onFocus={() => {}}\n      >\n        <div style={{ height }} ref={this.insideDOM}>\n          <div style={{ width: width, height: spaceAbove }} />\n          {visibleBlocks.map(i => seqBlocks[i])}\n        </div>\n      </div>\n    );\n  }\n}\n","import { COLOR_BORDER_MAP } from \"../../../../../Utils/colors\";\nimport * as React from \"react\";\nimport shortid from \"shortid\";\nconst tinycolor = require(\"tinycolor2\");\n\n/**\n * a single row of annotations. Multiple of these may be in one seqBlock\n * vertically stacked on top of one another in non-overlapping arrays\n */\nclass AnnotationRow extends React.PureComponent {\n  hoverOtherAnnotationRows = (className, opacity) => {\n    const elements = document\n      .getElementById(\"Linear-scroller\")\n      .getElementsByClassName(className);\n    for (let i = 0; i < elements.length; i += 1) {\n      elements[i].style.fillOpacity = opacity;\n    }\n  };\n\n  calcBorderColor = fillColor => {\n    const tColor = tinycolor(fillColor);\n    const HslColor = tColor.toHsl();\n    HslColor.s + 0.1 > 1 ? (HslColor.s = 1) : (HslColor.s += 0.1);\n    HslColor.l -= 0.26;\n    const borderColor = tinycolor(HslColor);\n    return `#${borderColor.toHex()}`;\n  };\n\n  renderAnnotation = (a, index) => {\n    const {\n      id,\n      inputRef,\n      seqBlockRef,\n      findXAndWidth,\n      firstBase,\n      lastBase,\n      resizing,\n      annotations,\n      fullSeq\n    } = this.props;\n    const { color, name, direction, start, end } = a;\n    const forward = direction === \"FORWARD\";\n    const reverse = direction === \"REVERSE\";\n    let { x: origX, width } = findXAndWidth(start, end);\n    const crossZero = start > end && end < firstBase;\n    // does the annotation begin or end within this seqBlock with a directionality?\n    const endFWD = forward && end > firstBase && end <= lastBase;\n    const endREV = reverse && start >= firstBase && start <= lastBase;\n\n    // does the annotation overflow to the left or the right of this seqBlock?\n    let overflowLeft = start < firstBase;\n    let overflowRight = end > lastBase || start === end; // start === end means covers whole plasmid\n\n    // if the annotation starts and ends in a SeqBlock, by circling all the way around,\n    // it will be rendered twice (once from the firstBase to start and another from\n    // end to lastBase)\n    // eg: https://user-images.githubusercontent.com/13923102/35816281-54571e70-0a68-11e8-92eb-ab56884337ac.png\n    const splitAnnotation =\n      annotations.reduce((acc, ann) => {\n        if (ann.id === a.id) {\n          return acc + 1;\n        }\n        return acc;\n      }, 0) > 1; // is this annotation in two pieces?\n\n    if (splitAnnotation) {\n      if (annotations.findIndex(ann => ann.id === a.id) === index) {\n        // we're in the first half of the split annotation\n        ({ x: origX, width } = findXAndWidth(firstBase, end));\n        overflowLeft = true;\n        overflowRight = false;\n      } else {\n        // we're in the second half of the split annotation\n        ({ x: origX, width } = findXAndWidth(start, lastBase));\n        overflowLeft = false;\n        overflowRight = true;\n      }\n    } else if (start > end) {\n      // the annotation crosses over the zero index and this needs to be accounted for\n      // this is very similar to the Block rendering logic in ../Selection/Selection.jsx\n      ({ x: origX, width } = findXAndWidth(\n        start > lastBase ? firstBase : Math.max(firstBase, start),\n        end < firstBase ? lastBase : Math.min(lastBase, end)\n      ));\n\n      // if this is the first part of annotation that crosses the zero index\n      if (start > firstBase) {\n        overflowLeft = true;\n        overflowRight = end > lastBase;\n      }\n\n      // if this is the second part of an annotation, check if it overflows\n      if (end < firstBase) {\n        overflowLeft = start < firstBase;\n        overflowRight = true;\n      }\n    } else if (start === end) {\n      // the annotation circles the entire plasmid and we aren't currently in a SeqBlock\n      // where the annotation starts or ends\n      ({ x: origX, width } = findXAndWidth(start, end + fullSeq.length));\n    }\n\n    // create padding on either side, vertically, of an annotation\n    const height = this.props.height * 0.8;\n\n    const rectProps = {\n      shapeRendering: resizing ? \"optimizeSpeed\" : \"geometricPrecision\"\n    };\n\n    const textProps = {\n      alignmentBaseline: \"middle\",\n      cursor: \"pointer\",\n      textAnchor: \"middle\",\n      textRendering: resizing ? \"optimizeSpeed\" : \"optimizeLegibility\",\n      x: width / 2,\n      y: height / 2 + 1.4,\n      style: {\n        color: \"black\",\n        fontWeight: 400\n      }\n    };\n\n    const cW = 4; // jagged cutoff width\n    const cH = height / 4; // jagged cutoff height\n    const [x, w] = [origX, width];\n\n    // create the SVG path, starting at the topLeft and working clockwise\n    // there is additional logic here for if the annotation overflows\n    // to the left or right of this seqBlock, where a \"jagged edge\" is created\n    const topLeft = endREV ? `M ${2 * cW} 0` : \"M 0 0\";\n    const topRight = endFWD ? `L ${width - 2 * cW} 0` : `L ${width} 0`;\n\n    let linePath;\n    if (a.type === \"insert\") {\n      linePath = `${topLeft} ${topRight}`;\n    } else {\n      let bottomRight = `L ${width} ${height}`; // flat right edge\n      if ((overflowRight && width > 10 * cW) || crossZero) {\n        bottomRight = `\n\t\t\t\tL ${width - cW} ${cH}\n\t\t\t\tL ${width} ${2 * cH}\n\t\t\t\tL ${width - cW} ${3 * cH}\n\t\t\t\tL ${width} ${4 * cH}`; // jagged right edge\n      } else if (endFWD) {\n        bottomRight = `\n\t\t\t\tL ${width} ${height / 2}\n\t\t\t\tL ${width - Math.min(2 * cW, w)} ${height}`; // arrow forward\n      }\n\n      let bottomLeft = `L 0 ${height} L 0 0`; // flat left edge\n      if (overflowLeft && width > 10 * cW) {\n        bottomLeft = `\n\t\t\t\tL 0 ${height}\n\t\t\t\tL ${cW} ${3 * cH}\n\t\t\t\tL 0 ${2 * cH}\n\t\t\t\tL ${cW} ${cH}\n\t\t\t\tL 0 0`; // jagged left edge\n      } else if (endREV) {\n        bottomLeft = `\n\t\t\t\tL ${Math.min(2 * cW, w)} ${height}\n\t\t\t\tL 0 ${height / 2}\n\t\t\t\tL ${Math.min(2 * cW, w)} 0`; // arrow reverse\n      }\n\n      linePath = `${topLeft} ${topRight} ${bottomRight} ${bottomLeft}`;\n    }\n\n    if (!resizing) {\n      if ((forward && overflowRight) || (forward && crossZero)) {\n        if (lastBase - start > 14) {\n          linePath += `\n\t\t\t\tM ${width - 3 * cW} ${cH}\n\t\t\t\tL ${width - 2 * cW} ${2 * cH}\n\t\t\t\tL ${width - 3 * cW} ${3 * cH}\n\t\t\t\tM ${width - 4 * cW} ${cH}\n\t\t\t\tL ${width - 3 * cW} ${2 * cH}\n\t\t\t\tL ${width - 4 * cW} ${3 * cH}`; // add double arrow forward\n        }\n      } else if ((reverse && overflowLeft) || (reverse && crossZero)) {\n        if (end - firstBase > 14) {\n          linePath += `\n\t\t\t\tM ${3 * cW} ${3 * cH}\n\t\t\t\tL ${2 * cW} ${cH * 2}\n\t\t\t\tL ${3 * cW} ${cH}\n\t\t\t\tM ${4 * cW} ${3 * cH}\n\t\t\t\tL ${3 * cW} ${cH * 2}\n\t\t\t\tL ${4 * cW} ${cH}`; // add double forward reverse\n        }\n      }\n    }\n    let strokeColor;\n    if (a.type === \"insert\") {\n      strokeColor = color;\n    } else {\n      strokeColor = COLOR_BORDER_MAP[color]\n        ? COLOR_BORDER_MAP[color]\n        : this.calcBorderColor(color);\n    }\n\n    const annotationPath = (\n      <path\n        id={a.id}\n        ref={inputRef(a.id, {\n          ref: a.id,\n          start: start,\n          end: end,\n          type: \"ANNOTATION\",\n          element: seqBlockRef\n        })}\n        className={a.id}\n        style={{\n          fillOpacity: 0.7,\n          cursor: \"pointer\",\n          fill: color,\n          stroke: strokeColor,\n          strokeWidth: a.type === \"insert\" ? 2.4 : 0.5\n        }}\n        {...rectProps}\n        d={linePath}\n        onMouseOver={() => this.hoverOtherAnnotationRows(a.id, 1.0)}\n        onMouseOut={() => this.hoverOtherAnnotationRows(a.id, 0.7)}\n        onFocus={() => 0}\n        onBlur={() => 0}\n      />\n    );\n\n    // determine whether the annotation name fits within the width of the annotation\n    const nameLength = name.length * 6.75; // aspect ratio of roboto mono is ~0.66\n    const nameFits = nameLength < width - 15;\n\n    return (\n      <g\n        key={`annotation_${id}_${a.id}_${index}`}\n        id={a.id}\n        transform={`translate(${x}, 0)`}\n      >\n        {annotationPath},\n        {nameFits ? (\n          <text\n            fontSize={11}\n            {...textProps}\n            id={a.id}\n            onMouseOver={() => this.hoverOtherAnnotationRows(a.id, 1.0)}\n            onMouseOut={() => this.hoverOtherAnnotationRows(a.id, 0.7)}\n            onFocus={() => {}}\n            onBlur={() => {}}\n          >\n            {name}\n          </text>\n        ) : null}\n      </g>\n    );\n  };\n\n  render() {\n    const { annotations, width, y } = this.props;\n\n    const height = this.props.height * 0.8;\n    const size = { width, height };\n    const gTranslate = `translate(0, ${y - 5})`;\n\n    return (\n      <g {...size} transform={gTranslate} className=\"linear-annotation-row\">\n        {annotations.map(this.renderAnnotation)}\n      </g>\n    );\n  }\n}\n\nexport default class AnnotationRows extends React.PureComponent {\n  render() {\n    const {\n      Annotations,\n      annotationRows,\n      yDiff,\n      findXAndWidth,\n      inputRef,\n      seqBlockRef,\n      onUnmount,\n      firstBase,\n      lastBase,\n      resizing,\n      fullSeq,\n      elementHeight\n    } = this.props;\n\n    if (!Annotations) return null;\n\n    return (\n      <g id=\"linear-annotations\">\n        {annotationRows.map((a, i) => {\n          const y = yDiff + elementHeight * i;\n          const id = shortid.generate();\n\n          return (\n            <AnnotationRow\n              id={id}\n              annotations={a}\n              y={y}\n              height={elementHeight}\n              key={id}\n              inputRef={inputRef}\n              seqBlockRef={seqBlockRef}\n              onUnmount={onUnmount}\n              findXAndWidth={findXAndWidth}\n              firstBase={firstBase}\n              lastBase={lastBase}\n              resizing={resizing}\n              fullSeq={fullSeq}\n            />\n          );\n        })}\n      </g>\n    );\n  }\n}\n","import React from \"react\";\n\n/**\n * a basepair indexing row for tracking the location of the current bp of DNA.\n */\nexport default class Index extends React.PureComponent {\n  // given each basepair in the sequence, go through each and find whether 1) it is divisible\n  // by the number set for tally thresholding and, if it is, 2) add its location to the list\n  // of positions for tallies\n  genTicks = () => {\n    const {\n      seq,\n      Zoom,\n      firstBase,\n      lineHeight,\n      size,\n      resizing,\n      findXAndWidth\n    } = this.props;\n    const seqLength = seq.length;\n\n    // the number of tallies on the x-axis is Zoom dependent:\n    // (0, 10]: every 50\n    // (10, 40]: every 20\n    // (40, 70]: every 10\n    // (70, 100] every 5\n    let tallies = 0;\n    switch (true) {\n      case Zoom > 85:\n        tallies = 5;\n        break;\n      case Zoom > 40:\n        tallies = 10;\n        break;\n      case Zoom > 10:\n        tallies = 20;\n        break;\n      case Zoom >= 0:\n        tallies = 50;\n        break;\n      default:\n        tallies = 10;\n    }\n\n    // create the array that will hold all the indexes in the array\n    const talPositions = [];\n    if (firstBase === 0) {\n      talPositions.push(1);\n    }\n\n    let i = 0;\n    while ((i + firstBase) % tallies !== 0) i += 1;\n    while (i < seqLength) {\n      if (i + firstBase !== 0) {\n        talPositions.push(i + firstBase);\n      }\n\n      i += tallies;\n    }\n\n    const tickStyle = {\n      width: 1,\n      height: 8,\n      shapeRendering: \"crispEdges\"\n    };\n\n    const textStyle = {\n      fontSize: 11,\n      textRendering: resizing ? \"optimizeSpeed\" : \"optimizeLegibility\"\n    };\n\n    return talPositions.map(p => {\n      const { x: leftDist } = findXAndWidth(p - 0.5, p - 0.5); // for midpoint\n      const tickFromLeft = leftDist;\n      let textFromLeft = leftDist; // 0.05 * 11\n\n      let digits = Math.ceil(Math.log10(p + 1)); // digits in num\n      // 0.91 is the aspect ratio of roboto mono, 11 is the font width. 0.91 * 11 = 10\n      const textWidth = digits * 10;\n      digits -= 1; // don't shift if there's just one digit\n      digits /= 2; // shift by half the number's width\n\n      textFromLeft -= digits * 10; // 10 = 0.91 x 11\n      textFromLeft = Math.max(0, textFromLeft); // keep off left edge\n      textFromLeft = Math.min(size.width - textWidth / 2, textFromLeft); // keep off right edge\n\n      const transTick = `translate(${tickFromLeft}, -${0.3 * lineHeight})`;\n      const transText = `translate(${textFromLeft}, ${-0.3 * lineHeight + 22})`;\n      return (\n        <React.Fragment key={p}>\n          {!resizing && <rect style={tickStyle} fill=\"#A3A3A3\" transform={transTick} />}\n          <text style={textStyle} transform={transText}>\n            {p}\n          </text>\n        </React.Fragment>\n      );\n    });\n  };\n\n  render() {\n    const { lineHeight, size, transform, Axis, resizing } = this.props;\n\n    if (!Axis) return null;\n\n    const axisStyle = {\n      width: size.width,\n      height: 1,\n      shapeRendering: resizing ? \"optimizeSpeed\" : \"crispEdges\"\n    };\n\n    return (\n      <g transform={transform}>\n        <rect\n          style={axisStyle}\n          fill=\"#B0B9C2\"\n          transform={`translate(0, -${0.3 * lineHeight})`}\n        />\n        {this.genTicks()}\n      </g>\n    );\n  }\n}\n","import * as React from \"react\";\nimport shortid from \"shortid\";\n\nclass LinearFind extends React.PureComponent {\n  render() {\n    const {\n      searchRows,\n      findXAndWidth,\n      indexYDiff,\n      compYDiff,\n      currSearchIndex,\n      seqBlockRef,\n      inputRef,\n      firstBase,\n      lastBase\n    } = this.props;\n\n    const findProps = {\n      height: 18,\n      stroke: \"black\",\n      strokeWidth: 0.8,\n      className: \"linear-sel-block\",\n      cursor: \"pointer\"\n    };\n\n    return searchRows.map(s => {\n      let { x, width } = findXAndWidth(s.start, s.end);\n      if (s.start > s.end) {\n        ({ x, width } = findXAndWidth(\n          s.start > lastBase ? firstBase : Math.max(firstBase, s.start),\n          s.end < firstBase ? lastBase : Math.min(lastBase, s.end)\n        ));\n      }\n      const fill =\n        s.index === currSearchIndex\n          ? \"rgba(255, 165, 7, 0.5)\"\n          : \"rgba(255, 251, 7, 0.5)\";\n      const id = shortid.generate();\n      const selReference = {\n        id: id,\n        start: s.start,\n        end: s.end,\n        type: \"FIND\",\n        element: seqBlockRef\n      };\n\n      return (\n        <rect\n          x={x}\n          y={s.row > 0 ? compYDiff - 10 : indexYDiff - 10}\n          width={width}\n          style={{ fill }}\n          key={id}\n          id={id}\n          ref={inputRef(id, selReference)}\n          {...findProps}\n        />\n      );\n    });\n  }\n}\nexport default LinearFind;\n","import * as React from \"react\";\nimport shortid from \"shortid\";\n\nexport class Edges extends React.Component {\n  id = shortid.generate();\n\n  componentDidMount = () => {\n    const { inputRef } = this.props;\n    // for selHandler.jsx\n    inputRef(this.id, { type: \"SELECT\" });\n  };\n\n  componentWillUnmount = () => {\n    const { onUnmount } = this.props;\n    onUnmount(this.id);\n  };\n\n  render() {\n    const {\n      findXAndWidth,\n      selectEdgeHeight,\n      firstBase,\n      lastBase,\n      resizing,\n      fullSeq,\n      seqSelection: { ref, start, end, clockwise }\n    } = this.props;\n\n    let startEdge = null;\n    let lastEdge = null;\n\n    if (clockwise) {\n      // clockwise, ie forward drag event\n      // the start or end edges are within this block\n      if (start >= firstBase && start < lastBase) startEdge = start;\n      if (end > firstBase && end <= lastBase) lastEdge = end;\n    } else {\n      // counterclockwise, ie reverse drag event\n      if (start > firstBase && start <= lastBase) startEdge = start;\n      if (end >= firstBase && end < lastBase) lastEdge = end;\n    }\n\n    // for cmd-a case\n    if (ref === \"ALL\" || (start === 0 && end === fullSeq.length - 1)) {\n      startEdge = null;\n      lastEdge = null;\n    }\n\n    // the end of the selection edges are not in this SeqBlock and\n    // do not need to be rendered\n    if (startEdge === null && lastEdge === null) {\n      return null;\n    }\n    if (startEdge === null) {\n      startEdge = lastEdge;\n      lastEdge = null;\n    }\n    let { x, width } = findXAndWidth(startEdge, lastEdge);\n\n    // if drag event in counter clockwise direction and both of the edges are\n    // within this range (if reverse but not both in one range, it'll be fine)\n    if (clockwise === false && startEdge !== null && lastEdge !== null) {\n      ({ x, width } = findXAndWidth(lastEdge, startEdge));\n    }\n\n    // the x position of the second edge\n    let secondEdgeX = x + width;\n    if (startEdge !== null && lastEdge !== null) {\n      if (\n        (start > end && clockwise === true) ||\n        (end > start && clockwise === false)\n      ) {\n        secondEdgeX = x - width;\n      } // in this scenario, the ending edge of the selection range is before the start\n    }\n\n    // inlining style in the SVG for speed sake\n    const rect = {\n      y: \"-10\",\n      style: {\n        fill: \"black\",\n        width: start === end && !ref ? 0.75 : 3\n      },\n      shapeRendering: resizing ? \"speedOptimize\" : \"auto\"\n    };\n\n    return (\n      <g className=\"linear-sel-edges\">\n        {startEdge !== null && (\n          <rect {...rect} x={x} height={selectEdgeHeight} />\n        )}\n        {lastEdge !== null && (\n          <rect {...rect} x={secondEdgeX} height={selectEdgeHeight} />\n        )}\n      </g>\n    );\n  }\n}\n\n// eslint-disable-next-line\nexport class Block extends React.PureComponent {\n  id = shortid.generate();\n\n  componentDidMount = () => {\n    const { inputRef } = this.props;\n    const selRange = { type: \"SELECT\" };\n    // selHandler.jsx\n    inputRef(this.id, selRange);\n  };\n\n  componentWillUnmount = () => {\n    const { onUnmount } = this.props;\n    onUnmount(this.id);\n  };\n\n  render() {\n    const {\n      findXAndWidth,\n      selectHeight,\n      firstBase,\n      lastBase,\n      resizing,\n      fullSeq,\n      seqSelection\n    } = this.props;\n    const { ref, clockwise } = seqSelection;\n    let { start, end } = seqSelection;\n\n    // there's no need to render a selection block (rect) if just one point\n    // has been selected\n    if (start === end && ref !== \"ALL\") return null;\n    if (ref === \"ALL\" || (start === 0 && end === fullSeq.length)) {\n      // it's not \"ALL\" or some element's id\n      start = 0;\n      end = 0;\n    }\n\n    let x;\n    let width;\n    let secondBlock = null;\n    if (clockwise && end > start) {\n      // does not cross the zero index, FWD direction\n      if (start <= lastBase && end > firstBase) {\n        ({ x, width } = findXAndWidth(\n          Math.max(firstBase, start),\n          Math.min(lastBase, end)\n        ));\n      }\n    } else if (clockwise && start > end) {\n      // crosses the zero index in FWD direction\n      if (!(start > lastBase && end < firstBase)) {\n        // is this seq block relevant\n        if (start < lastBase && end > firstBase) {\n          // the selection range both starts and ends in this seqblock, but wraps\n          // all the way around the rest of the plasmid\n          // ex: https://user-images.githubusercontent.com/13923102/34791431-f56df23a-f612-11e7-94b4-e302ede155a0.png\n          const { x: secBlockX, width: secBlockWidth } = findXAndWidth(\n            start,\n            lastBase\n          );\n          secondBlock = (\n            <rect\n              x={secBlockX}\n              y={-10}\n              height={selectHeight + 5}\n              width={secBlockWidth}\n              className=\"linear-sel-block\"\n            />\n          );\n          ({ x, width } = findXAndWidth(firstBase, end));\n        } else {\n          ({ x, width } = findXAndWidth(\n            start > lastBase ? firstBase : Math.max(firstBase, start),\n            end < firstBase ? lastBase : Math.min(lastBase, end)\n          ));\n        }\n      }\n    } else if (!clockwise && start > end) {\n      // does not cross zero index but is in reverse direction\n      if (end <= lastBase && start >= firstBase) {\n        ({ x, width } = findXAndWidth(\n          Math.max(firstBase, end),\n          Math.min(lastBase, start)\n        ));\n      }\n    } else if (!clockwise && end > start) {\n      // crosses zero index and is in reverse direction\n      if (start > firstBase || end < lastBase) {\n        if (start > firstBase && start < lastBase && end > firstBase) {\n          // the selection range both starts and ends in this seqblock, but wraps\n          // all the way around the rest of the plasmid\n          // ex: https://user-images.githubusercontent.com/13923102/34791431-f56df23a-f612-11e7-94b4-e302ede155a0.png\n          const { x: secBlockX, width: secBlockWidth } = findXAndWidth(\n            end,\n            lastBase\n          );\n          secondBlock = (\n            <rect\n              x={secBlockX}\n              y={-10}\n              height={selectHeight + 5}\n              width={secBlockWidth}\n              className=\"linear-sel-block\"\n              shapeRendering={resizing ? \"optimizeSpeed\" : \"auto\"}\n            />\n          );\n          ({ x, width } = findXAndWidth(firstBase, start));\n        } else {\n          ({ x, width } = findXAndWidth(\n            start < firstBase ? end : firstBase,\n            end > lastBase ? start : lastBase\n          ));\n        }\n      }\n    }\n\n    // sreflect\n    if (ref === \"ALL\" || start === end) {\n      ({ x, width } = findXAndWidth(\n        Math.max(firstBase, 0),\n        Math.min(lastBase, fullSeq.length + 1)\n      ));\n    }\n\n    // nothing was set for this selection block\n    if (!x && !width) return null;\n\n    const rectId = shortid.generate();\n\n    return (\n      <React.Fragment>\n        <rect\n          id={rectId}\n          x={x}\n          y={-10}\n          height={selectHeight + 5}\n          width={width}\n          className=\"linear-sel-block\"\n          shapeRendering={resizing ? \"optimizeSpeed\" : \"auto\"}\n        />\n        {secondBlock}\n      </React.Fragment>\n    );\n  }\n}\n\nexport default {\n  Edges: Edges,\n  Block: Block\n};\n","import * as React from \"react\";\nimport Annotations from \"./Annotations/Annotations\";\nimport IndexRow from \"./Index/Index\";\nimport LinearFind from \"./LinearFind/LinearFind\";\nimport Selection from \"./Selection/Selection\";\n\n/**\n * SeqBlock\n *\n * Comprised of:\n * \t   IndexRow (the x axis basepair index)\n * \t   AnnotationRow (annotations)\n * \t\t PrimerRow (primers)\n * \t   Selection (cursor selection range)\n * \t   ORFrames (open reading frames)\n * \t   CutSites\n * \t   Find (regions that match the users current find search)\n *\n * a single block of linear sequence. Essentially a row that holds\n * the sequence, and flair around it including the\n * complementary sequence, sequence index, and anotations *\n */\nexport default class SeqBlock extends React.PureComponent {\n  static defaultProps = {};\n\n  componentWillUnmount = () => {\n    const { onUnmount, id } = this.props;\n    onUnmount(id);\n  };\n\n  /**\n   * @typedef {Object} SeqBlockPosition\n   * @property {Number}     x              [the x positioning, from left...]\n   * @property {Number}     width          [the width of the passed element]\n   * @property {Number}     charWidth      [the width of each character in the element]\n   */\n\n  /**\n   * findXAndWidth\n   *\n   * a helper method that's used in several of the child components to figure\n   * out how far from the left the element is, and how wide it should be\n   *\n   * @param  {Number} firstIndex [the first index of the annotation/ORF/cutSite etc]\n   * @param  {Number} lastIndex  [last index/basepair of the element]\n   * @return {SeqBlockPosition}  [the position information of the given element]\n   */\n  findXAndWidth = (firstIndex = 0, lastIndex = 0) => {\n    const {\n      firstBase,\n      size,\n      seq: { length: seqLength }\n    } = this.props;\n    const lastBase = firstBase + seqLength;\n\n    // find the distance from the left to start\n    let x = 0;\n    if (firstIndex >= firstBase) {\n      x = ((firstIndex - firstBase) / seqLength) * size.width;\n      x = Math.max(x, 0) || 0;\n    }\n\n    // find the width for the current annotation\n    let { width } = size;\n    if (firstIndex === lastIndex) {\n      width = 0;\n    } else if (firstIndex > firstBase || lastIndex < lastBase) {\n      width =\n        (Math.min(lastIndex, lastBase) - Math.max(firstIndex, firstBase)) /\n        seqLength;\n      width *= size.width;\n      width = Math.abs(width) || 0;\n    }\n    return { x, width };\n  };\n\n  render() {\n    const {\n      seq,\n      compSeq,\n      fullSeq,\n      annotationRows,\n      searchRows,\n      currSearchIndex,\n      blockHeight,\n\n      Axis,\n\n      seqFontSize,\n      firstBase,\n      size,\n      lineHeight,\n      elementHeight,\n      mouseEvent,\n\n      inputRef,\n      id,\n      onUnmount,\n      resizing,\n\n      zoomed,\n\n      showSearch,\n      seqSelection,\n      findState,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    } = this.props;\n\n    const partState = {\n      showSearch,\n      seqSelection,\n      findState,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    };\n\n    if (!size.width || !size.height) return null;\n\n    const svgProps = {\n      display: \"block\",\n      height: blockHeight,\n      width: size.width\n    };\n    const textProps = {\n      dominantBaseline: \"middle\",\n      fontSize: seqFontSize,\n      lengthAdjust: \"spacing\",\n      textAnchor: \"start\",\n      textLength: size.width,\n      textRendering: resizing ? \"optimizeSpeed\" : \"optimizeLegibility\"\n    };\n\n    const lastBase = firstBase + seq.length;\n    const seqRange = {\n      ref: id,\n      start: firstBase,\n      end: lastBase,\n      type: \"SEQ\",\n      element: this\n    };\n\n    // height and yDiff of the sequence strand\n    const indexYDiff = 0;\n    const indexHeight = zoomed ? lineHeight : 0; // bases not shown at < 10 zoom\n\n    // height and yDiff of the complement strand\n    const compYDiff = indexYDiff + indexHeight;\n    const compHeight = zoomed ? lineHeight : 0;\n\n    // height and yDiff of annotations\n    const annYDiff = compYDiff + compHeight;\n    const annHeight = elementHeight * annotationRows.length;\n\n    // calc the height necessary for the sequence selection\n    let selectHeight = indexHeight + compHeight + annHeight;\n    let selectEdgeHeight = Axis ? selectHeight + lineHeight : selectHeight;\n\n    // needed because otherwise the selection height is very small\n    if (!zoomed && selectHeight <= elementHeight) {\n      selectHeight += lineHeight;\n      selectEdgeHeight += lineHeight;\n    }\n\n    // find index row (the actual bar+ticks) Y diff\n    const elementRowShown = annotationRows.length;\n    let indexRowYDiff = annYDiff + annHeight;\n    if (elementRowShown) {\n      indexRowYDiff += 0.5 * elementHeight;\n      selectHeight += 0.5 * elementHeight;\n      selectEdgeHeight += 0.25 * elementHeight;\n    }\n    return (\n      <svg\n        {...svgProps}\n        className=\"SeqBlock\"\n        id={id}\n        ref={inputRef(id, seqRange)}\n        onMouseDown={mouseEvent}\n        onMouseUp={mouseEvent}\n        onMouseMove={mouseEvent}\n        cursor=\"text\"\n      >\n        <g transform=\"translate(0, 10)\">\n          <Selection.Block\n            selectHeight={selectHeight}\n            findXAndWidth={this.findXAndWidth}\n            inputRef={inputRef}\n            onUnmount={onUnmount}\n            firstBase={firstBase}\n            lastBase={lastBase}\n            fullSeq={fullSeq}\n            {...partState}\n          />\n          {zoomed ? (\n            <text {...textProps} y={indexYDiff} id={id}>\n              {seq}\n            </text>\n          ) : null}\n          {compSeq && zoomed ? (\n            <text {...textProps} y={compYDiff} id={id}>\n              {compSeq}\n            </text>\n          ) : null}\n          <Annotations\n            {...this.props}\n            findXAndWidth={this.findXAndWidth}\n            lastBase={lastBase}\n            yDiff={annYDiff}\n            seqBlockRef={this}\n            fullSeq={fullSeq}\n          />\n          {searchRows.length ? (\n            <LinearFind\n              {...this.props}\n              findXAndWidth={this.findXAndWidth}\n              indexYDiff={indexYDiff}\n              compYDiff={compYDiff}\n              currSearchIndex={currSearchIndex}\n              seqBlockRef={this}\n              lastBase={lastBase}\n            />\n          ) : null}\n          <Selection.Edges\n            selectEdgeHeight={selectEdgeHeight}\n            findXAndWidth={this.findXAndWidth}\n            inputRef={inputRef}\n            onUnmount={onUnmount}\n            firstBase={firstBase}\n            lastBase={lastBase}\n            fullSeq={fullSeq}\n            {...partState}\n          />\n          <IndexRow\n            {...this.props}\n            transform={`translate(0, ${indexRowYDiff})`}\n            findXAndWidth={this.findXAndWidth}\n          />\n        </g>\n      </svg>\n    );\n  }\n}\n","import { isEqual } from \"lodash\";\nimport * as React from \"react\";\nimport shortid from \"shortid\";\nimport withViewerHOCs from \"../handlers\";\nimport {\n  createMultiRows,\n  createSingleRows,\n  stackElements\n} from \"../partElementsToRows\";\nimport InfiniteScroll from \"./InfiniteScroll/InfiniteScroll\";\nimport \"./Linear.scss\";\nimport SeqBlock from \"./SeqBlock/SeqBlock\";\n\n/**\n * A linear sequence viewer.\n *\n * Comprised of SeqBlock(s), which are themselves comprised of:\n * \tSeqBlock:\n * \t\tSeqRow\n * \t\tIndexRow (axis)\n * \t\tAnnotations\n *\n * the width, sequence of each seqBlock, annotations,\n * indexRow, is passed in the child component\n *\n * seq: a string of the DNA/RNA to be displayed/manipulated\n * Zoom: a number (1-100) for the sizing of the sequence\n * comp: whether or not to show complement\n * compSeq: the complement sequence to the orig sequence\n * annotations: an array of annotations to show above the seq\n */\nclass Linear extends React.Component {\n  shouldComponentUpdate = nextProps => {\n    // check whether we even want to update props. Don't do anything if relevant prop\n    // have not changed\n    const { name, ...rest } = nextProps;\n    const { name: origName, ...origRest } = this.props;\n    return !isEqual(rest, origRest);\n  };\n\n  /**\n   * given all the information needed to render all the seqblocks (ie, sequence, compSeq\n   * list of annotations), cut up all that information into an array.\n   * Each element in that array pertaining to one SeqBlock\n   *\n   * For example, if each seqblock has 2 bps, and the seq is \"ATGCAG\", this should first\n   * make an array of [\"AT\", \"GC\", \"AG\"], and then pass \"AT\" to the first SeqBlock, \"GC\" to\n   * the second seqBlock, and \"AG\" to the third seqBlock.\n   */\n  render() {\n    const {\n      seq,\n      compSeq,\n      Zoom,\n      Axis,\n      Annotations,\n      annotations,\n\n      lineHeight,\n      elementHeight,\n      bpsPerBlock,\n      size,\n      onUnMount,\n\n      findState: { searchResults = [], searchIndex },\n      showSearch,\n      seqSelection,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    } = this.props;\n\n    const partState = {\n      showSearch,\n      seqSelection,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    };\n\n    // un-official definition for being Zoomed in. Being over 10 seems like a decent cut-off\n    const Zoomed = Zoom > 10;\n\n    // the actual fragmenting of the sequence into subblocks. generates all info that will be needed\n    // including sequence blocks, complement blocks, annotations, blockHeights, yDifferentials,\n    const seqLength = seq.length;\n    let arrSize = Math.round(Math.ceil(seqLength / bpsPerBlock));\n    if (arrSize === Number.POSITIVE_INFINITY) arrSize = 1;\n\n    const ids = new Array(arrSize); // array of SeqBlock ids\n    const seqs = new Array(arrSize); // arrays for sequences...\n    const compSeqs = new Array(arrSize); // complements...\n    const blockHeights = new Array(arrSize); // block heights...\n    const yDiffs = new Array(arrSize); // y differentials...\n\n    const annotationRows = Annotations // annotations...\n      ? createMultiRows(\n          stackElements(annotations, seq.length),\n          bpsPerBlock,\n          arrSize\n        )\n      : new Array(arrSize).fill([]);\n\n    const searchRows =\n      searchResults && searchResults.length\n        ? createSingleRows(searchResults, bpsPerBlock, arrSize)\n        : new Array(arrSize).fill([]);\n\n    let yDiffCumm = 0; // cummulative y differential tracker\n    for (let i = 0; i < arrSize; i += 1) {\n      const firstBase = i * bpsPerBlock;\n      const lastBase = firstBase + bpsPerBlock;\n      ids[i] = shortid.generate();\n\n      // cut the new sequence and, if also looking for complement, the complement as well\n      seqs[i] = seq.substring(firstBase, lastBase);\n      compSeqs[i] = compSeq.substring(firstBase, lastBase);\n\n      const spacingHeight = 0.25 * elementHeight;\n      // find the line height for the seq block based on how many rows need to be shown\n      let blockHeight = lineHeight; // this is for padding between the rows\n      if (Zoomed) {\n        blockHeight += lineHeight; // is Zoomed in enough + 2px margin\n        blockHeight += lineHeight; // double for complement + 2px margin\n      }\n      if (Axis) {\n        blockHeight += 25; // another for index row (height is fixed right now)\n      }\n      if (Annotations && annotationRows[i].length) {\n        blockHeight += annotationRows[i].length * elementHeight + spacingHeight;\n      }\n      blockHeights[i] = blockHeight;\n\n      // update the yDifferentialMap for the current block\n      yDiffs[i] = yDiffCumm;\n      yDiffCumm += blockHeight;\n    }\n    const seqBlocks = [];\n    let yDiff = 0;\n    for (let i = 0; i < arrSize; i += 1) {\n      const firstBase = i * bpsPerBlock;\n      let blockSize = { ...size };\n      if (i + 1 === arrSize) {\n        blockSize = {\n          ...size,\n          width: (seqs[i].length / bpsPerBlock) * size.width\n        };\n      }\n      seqBlocks.push(\n        <SeqBlock\n          {...this.props}\n          key={`${ids[i]}_block`}\n          id={ids[i]}\n          y={yDiff}\n          seq={seqs[i]}\n          compSeq={compSeqs[i]}\n          blockHeight={blockHeights[i]}\n          annotationRows={annotationRows[i]}\n          searchRows={searchRows[i]}\n          currSearchIndex={searchIndex}\n          firstBase={firstBase}\n          onUnmount={onUnMount}\n          fullSeq={seq}\n          size={blockSize}\n          zoomed={Zoomed}\n          {...partState}\n        />\n      );\n\n      yDiff += blockHeights[i];\n    }\n\n    return (\n      seqBlocks.length && (\n        <InfiniteScroll\n          seqBlocks={seqBlocks}\n          blockHeights={blockHeights}\n          totalHeight={blockHeights.reduce((acc, h) => acc + h, 0)}\n          size={size}\n          bpsPerBlock={bpsPerBlock}\n        />\n      )\n    );\n  }\n}\n\nexport default withViewerHOCs(Linear);\n","import { isEqual } from \"lodash\";\nimport * as React from \"react\";\nimport sizeMe from \"react-sizeme\";\nimport CircularViewer from \"./Circular/Circular\";\nimport LinearViewer from \"./Linear/Linear\";\nimport \"./SeqViewer.scss\";\n\nexport const CIRC_CONSTS = {\n  DROP_YDIFF: 13,\n  DROP_RADIUS_SCALE: 0.42\n};\n\n/**\n * a parent sequence viewer component that holds whatever is common between\n * the linear and circular sequence viewers. The Header is an example\n */\nclass SeqViewer extends React.Component {\n  static defaultProps = {\n    Axis: true,\n    Zoom: 50,\n    Annotations: true,\n    Circular: false\n  };\n\n  static options = {\n    linear: {\n      checkBoxes: [\"Annotations\", \"Axis\"],\n      sliders: [\"Zoom\"]\n    },\n    circular: {\n      checkBoxes: [\"Annotations\", \"Axis\"],\n      sliders: [\"centralIndex\", \"Zoom\"]\n    }\n  };\n\n  static WIDTH_MULTIPLIER = 0.97;\n\n  constructor(props) {\n    super(props);\n\n    const { Axis, Annotations, Circular } = props;\n\n    let { Zoom } = props;\n    if (Circular) {\n      Zoom = 0;\n    }\n    const resizing = false;\n\n    this.state = {\n      Axis,\n      Zoom,\n      Annotations,\n      resizing\n    }; // store the viewer settings in state\n  }\n\n  /** this is here because the size listener is returning a new \"size\" prop every time */\n  shouldComponentUpdate = (nextProps, nextState) =>\n    !isEqual(nextProps, this.props) || !isEqual(nextState, this.state);\n\n  unsub = () => {};\n\n  /**\n   * callbacks for the options dropdown to change viewer parameters\n   * @param  {React.SyntheticEvent} e    callback value from a click or change to the react-slider\n   */\n  seqStateChange = e => {\n    const { Circular } = this.props;\n    let { Zoom } = this.state;\n    const { name, type } = e.target;\n\n    if (e.target && type === \"slider\") {\n      const { value } = e.target;\n      this.setState({ [name]: value });\n    } else if (e.target && type === \"checkbox\") {\n      const { checked } = e.target;\n      this.setState({ [name]: checked });\n    } else if (e.target && type === \"submit\") {\n      const {\n        part: { seq }\n      } = this.props;\n\n      if (seq.length < 200) {\n        Zoom = Circular ? 0 : 50;\n      }\n      this.setState({ Zoom });\n    }\n  };\n\n  unsub = () => {};\n\n  /**\n   * given the width of the screen, and the current Zoom, how many basepairs should be displayed\n   * on the screen at a given time and what should their size be\n   */\n  linearProps = () => {\n    const { Zoom = 50 } = this.state;\n\n    const {\n      size: { height, width }\n    } = this.props;\n\n    const seqFontSize = Math.min(Math.round(Zoom * 0.1 + 9.5), 18); // max 18px\n\n    const size = {\n      height: height - 35 || 0,\n      width: width * SeqViewer.WIDTH_MULTIPLIER\n    };\n\n    // otherwise the sequence needs to be cut into smaller subsequences\n    // a sliding scale in width related to the degree of Zoom currently active\n    let bpsPerBlock = Math.round((size.width / seqFontSize) * 1.6) || 1; // width / 1 * seqFontSize\n\n    if (Zoom <= 5) {\n      bpsPerBlock *= 3;\n    } else if (Zoom <= 10) {\n      // really ramp up the range, since at this zoom it'll just be a line\n      bpsPerBlock *= 2;\n    } else if (Zoom > 70) {\n      // keep font height the same but scale number of bps in one row\n      bpsPerBlock = Math.round(bpsPerBlock * (70 / Zoom));\n    }\n\n    const charWidth = size.width / bpsPerBlock; // width of each basepair\n\n    const lineHeight = 1.4 * seqFontSize; // aspect ratio is 1.4 for roboto mono\n    const elementHeight = 16; // the height, in pixels, of annotations, ORFs, etc\n\n    return {\n      seqFontSize,\n      lineHeight,\n      elementHeight,\n      bpsPerBlock,\n      charWidth,\n      size,\n      Linear: true\n    };\n  };\n\n  /**\n   * given the length of the sequence and the dimensions of the viewbox, how should\n   * Zoom of the plasmid viewer affect the radius of the circular viewer and its vertical shift\n   *\n   * minPixelPerBP = s / 50 where\n   * s = theta * radius where\n   * radius = h / 2 + c ^ 2 / 8 h    (https://en.wikipedia.org/wiki/Circular_segment)\n   * and theta = 50 / seqLength\n   */\n  circularProps = () => {\n    const { Zoom = 0 } = this.state;\n    const {\n      size: oldSize,\n      part: {\n        seq: { length: seqLength }\n      }\n    } = this.props;\n\n    // adjust for the header above the Circular component\n    const newSize = oldSize.height - 45;\n    const size = {\n      height: newSize || 0,\n      width: oldSize.width\n    };\n    const center = {\n      x: size.width / 2,\n      y: size.height / 2\n    };\n\n    const limitingDim = Math.min(size.height, size.width);\n\n    // find the number of currently shown basepairs along the arc, using an exponential curve\n    // between (0, seqLength) and (100, 50) (Zoom, BPs shown on arc)\n    // this curve was generated using desmos so that, at max zoom, there's always ~50 bps,\n    // regardless of plasmid size and, at minimum zoom, the entire length of the plasmid.\n    // this was originally a linear line, but too few bps were shown in the 15-70 range\n    // curve params for future adjustment:\n    // https://user-images.githubusercontent.com/13923102/36227188-43a80494-119e-11e8-8196-a173a96ebff8.png\n    const exp = 0.83; // exponent... greater exp leads to flatter curve (c in fig)\n    const beta = Math.exp(Math.log(50 / seqLength) / -(100 ** exp)); // beta coefficient (b in fig)\n    const bpsOnArc = seqLength * beta ** -(Zoom ** exp); // calc using the full expression\n\n    // scale the radius so only (bpsOnArc) many bps are shown\n    let radius = limitingDim * 0.34;\n\n    const maxPixelPerBP = limitingDim / 100.0; // fully zoomed on 50 bps; 1.1 is approximate\n    // for bps on circular vs linear index line across the viewer\n    const minPixelPerBP = (radius * Math.PI) / seqLength; // not zoomed at all, whole plasmid\n\n    // slope from (0, minPixelPerBP) to (100, maxPixelPerBP)\n    const pixelSlope = (maxPixelPerBP - minPixelPerBP) / 100.0; // from zero to 100 zoom\n    const pixelPerBP = pixelSlope * Zoom + minPixelPerBP; // equation of a line\n    const totalPixelsOfArc = pixelPerBP * bpsOnArc;\n\n    // honestly I don't know the signif of this coefficent 0.84 (Josh)\n    // slope from (0, y) to (100, 0)\n    // trying to avoid dividing by 0\n    const radiusAdjust = center.y / Math.max(0.1, 100 * (100 - Zoom + 1));\n    radius = totalPixelsOfArc / (Math.PI * (bpsOnArc / seqLength));\n    let yDiff = radius - radiusAdjust;\n    if (Zoom === 0) {\n      yDiff = 0; // stupid hack\n    }\n    return { radius, yDiff, Linear: false, size, bpsOnArc, center };\n  };\n\n  render() {\n    const {\n      Circular: CircularProp,\n      part,\n      part: {\n        seq: { length: seqLength } // determine the length of the currently active part\n      },\n      size,\n      showSearch,\n      seqSelection,\n      findState,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    } = this.props;\n    const partState = {\n      showSearch,\n      seqSelection,\n      findState,\n      circularCentralIndex,\n      linearCentralIndex,\n      setPartState\n    };\n\n    return (\n      <div\n        className=\"SeqViewer-container\"\n        style={{ zIndex: CircularProp ? 2 : 3 }}\n      >\n        {CircularProp && (\n          <CircularViewer\n            {...part}\n            {...this.state}\n            {...this.circularProps()}\n            {...partState}\n            size={size}\n          />\n        )}\n        {!CircularProp && (\n          <LinearViewer\n            {...part}\n            {...this.state}\n            {...this.linearProps()}\n            seqLength={seqLength}\n            {...partState}\n            size={size}\n          />\n        )}\n      </div>\n    );\n  }\n}\n\nexport default sizeMe({ monitorWidth: true, monitorHeight: true })(SeqViewer);\n","import blankImg from \"../assets/empty-workspace-graphic-color.svg\";\nimport React from \"react\";\nimport \"./BlankPage.scss\";\n\n/**\n * Blank Page\n */\nconst BlankPage = () => (\n  <div id=\"BlankPage\">\n    <img id=\"splash\" src={blankImg} alt=\"Workspace\" />\n  </div>\n);\n\nexport default BlankPage;\n","import shortid from \"shortid\";\nimport { genRandomColor } from \"./colors\";\n\n/**\n * Resources shareable throughout Loom\n */\n\n/**\n * Map of nucleotide bases\n */\nexport const nucleotides = { a: \"a\", c: \"c\", t: \"t\", g: \"g\", u: \"u\" };\n\n/**\n * Map of common nucleotide wildcards to their translations\n */\nexport const nucleotideWildCards = {\n  y: { c: \"c\", t: \"t\" },\n  r: { a: \"a\", g: \"g\" },\n  w: { a: \"a\", t: \"t\" },\n  s: { g: \"g\", c: \"c\" },\n  k: { t: \"t\", g: \"g\" },\n  m: { c: \"c\", a: \"a\" },\n  d: { a: \"a\", g: \"g\", t: \"t\" },\n  v: { a: \"a\", c: \"c\", g: \"g\" },\n  h: { a: \"a\", c: \"c\", t: \"t\" },\n  b: { c: \"c\", g: \"g\", t: \"t\" },\n  x: { a: \"a\", c: \"c\", g: \"g\", t: \"t\" },\n  n: { a: \"a\", c: \"c\", g: \"g\", t: \"t\" }\n};\n\n/**\n * Translate common nucleotide wildcards\n *\n * Search string sequence for nucleotide wildcards\n * and replace with proper regex\n *\n * @param {String} query\n * @return {String} [/regex/]\n */\nexport const translateWildNucleotides = nucleotideSequence =>\n  nucleotideSequence\n    .toLowerCase()\n    .split(\"\")\n    .map(letter =>\n      nucleotideWildCards[letter]\n        ? `(${Object.keys(nucleotideWildCards[letter]).join(\"|\")})`\n        : letter\n    )\n    .join(\"\");\n\n/**\n * Find the mismatches\n * @param {string} sequence\n * @param {string} match: match sequence\n * @return {array} mismatches: array of indexes of mismatches\n */\nexport const getMismatchIndices = (sequence, match) =>\n  sequence\n    .split(\"\")\n    .map((nucleotide, i) => {\n      if (nucleotide !== match.split(\"\")[i]) {\n        return i;\n      }\n      return -1;\n    })\n    .filter(e => e !== -1);\n\n/**\n * Combine sequential indices into ranges\n * @param {array} indices\n * @return {array} array of ranges stored as arrays with start [0] and end [1]\n */\nexport const returnRanges = indices => {\n  let currStart = indices[0];\n  let currCount = indices[0] - 1;\n  const ranges = [];\n  indices.forEach((index, i) => {\n    if (index > currCount + 1) {\n      ranges.push([currStart, indices[i - 1]]);\n      currStart = index;\n      currCount = index - 1;\n    }\n    if (index === indices[indices.length - 1]) {\n      ranges.push([currStart, index]);\n    }\n    currCount += 1;\n  });\n  return ranges;\n};\n\n/**\n * Calculate the GC% of a sequence\n * @param {string} sequence\n */\nexport const calcGC = sequence =>\n  sequence === \"\"\n    ? 0\n    : ((sequence.match(/[CG]/gi) || []).length / sequence.length) * 100;\n\n/**\n * Calculate the melting temp for a given sequence\n * @param {string} sequence\n * @param {string} match: sequence to match against\n */\nexport const calcTm = (sequence, match = sequence) => {\n  const numberbps = sequence.length; // number of base pairs\n  const numbergcs = (sequence.match(/[CG]/gi) || []).length; // number of Gs and Cs\n  const numberats = (sequence.match(/[AT]/gi) || []).length; // number of As and Ts\n  const numbermismatches = getMismatchIndices(sequence, match).length; // # of mismatches\n  const gcpercent = calcGC(sequence);\n  // https://www.biophp.org/minitools/melting_temperature/demo.php?formula=basic\n  // formula valid for bps 0-14\n  if (numberbps < 14) {\n    return 2 * numberats + 4 * numbergcs;\n  }\n\n  // http://depts.washington.edu/bakerpg/primertemp/\n  // formula valid for bps  25-45, gc% > 40 and sequence terminates in one or more G/C\n  if (\n    numberbps > 24 &&\n    numberbps < 46 &&\n    gcpercent > 40 &&\n    sequence.slice(0, 1) in { G: \"G\", C: \"C\" }\n  ) {\n    return (\n      (100 / numberbps) *\n      (0.815 * numberbps + 0.41 * numbergcs - numbermismatches - 6.75)\n    );\n  }\n\n  // https://www.biophp.org/minitools/melting_temperature/demo.php?formula=basic\n  // generic formula for bps 14+ no mismatch\n  return Math.round(64.9 + (41 * (numbergcs - 16.4)) / numberbps);\n};\n\n/**\n * Calculate the length of a sequence\n * @param {number} start: start index of selection\n * @param {number} end: end index of selection\n * @param {number} seqLength: length of sequence\n */\nexport const calcLength = (start, end, seqLength) => {\n  if (end > start) return end - start;\n  if (end === start) return seqLength;\n  return seqLength - start + end;\n};\n\n/**\n * Reverses a string sequence\n * @param {string} sequence\n */\nexport const reverse = sequence =>\n  sequence\n    .split(\"\")\n    .reverse()\n    .join(\"\");\n\n/**\n * reverse the direction\n * @param direction\n */\nexport const reverseDirection = direction => {\n  if (direction === \"FORWARD\") {\n    return \"REVERSE\";\n  }\n  if (direction === \"REVERSE\") {\n    return \"FORWARD\";\n  }\n  return \"NONE\";\n};\n\nexport const reIndex = (sequence, start) => {\n  const reIndexed = sequence.substr(start) + sequence.substr(0, start);\n  return reIndexed;\n};\n\nexport const defaultSelection = {\n  id: \"\",\n  ref: null,\n  start: 0,\n  end: 0,\n  clockwise: true\n};\n\n/**\n * a default annotation generator\n */\nexport const annotationFactory = () => ({\n  id: shortid.generate(),\n  color: genRandomColor(),\n  name: \"Untitled\",\n  type: \"\",\n  start: 0,\n  end: 0,\n  direction: \"NONE\"\n});\n","import * as React from \"react\";\nimport SeqViewer from \"./SeqViewer/SeqViewer\";\nimport \"./PartExplorer.scss\";\nimport BlankPage from \"../BlankPage/BlankPage\";\nimport request from \"request\";\nimport shortid from \"shortid\";\nimport { annotationFactory } from \"../Utils/sequence\";\n\n/**\n * a container for investigating the meta and sequence information of a part\n */\nclass PartExplorer extends React.PureComponent {\n  state = {\n    showSearch: false,\n    seqSelection: { type: \"\", ref: null, start: 0, end: 0, clockwise: true },\n    findState: {\n      searchResults: [],\n      searchIndex: 0\n    },\n    circularCentralIndex: 0,\n    linearCentralIndex: 0\n  };\n\n  onSelection = onSelectionFunction => {\n    const { seqSelection } = this.state;\n    onSelectionFunction(seqSelection);\n    return seqSelection;\n  };\n\n  setPartState = state => {\n    let newState = Object.keys(state).reduce((newState, key) => {\n      if (typeof state[key] === \"object\") {\n        newState[key] = { ...this.state[key], ...state[key] };\n      } else {\n        newState[key] = state[key];\n      }\n      return newState;\n    }, {});\n    const { ...rest } = this.state;\n    this.setState({ ...rest, ...newState });\n  };\n\n  lambdaAnnotate = async part => {\n    const result = await new Promise((resolve, reject) => {\n      request.post(\n        {\n          uri: `${String(process.env.REACT_APP_LAMBDA_URL)}/annotate`,\n          method: \"POST\",\n          json: JSON.stringify({\n            part: { id: shortid.generate(), seq: part.seq }\n          }),\n          headers: {\n            \"Content-Type\": \"application/json\"\n          }\n        },\n        (err, resp) => {\n          if (err) {\n            console.log(\"Error with automatic annotation: \", err);\n            return reject(err);\n          }\n          return resolve(resp.toJSON());\n        }\n      );\n    });\n\n    if (result.statusCode !== 200) {\n      const err = JSON.stringify(result.body);\n      throw new Error(`Lambda annotations failed. Server response: ${err}`);\n    }\n\n    return result;\n  };\n\n  autoAnnotate = async part => {\n    const result = await this.lambdaAnnotate(part);\n    let annotations = result.body.map(a => ({ ...annotationFactory(), ...a }));\n    // add in the annotations already on the part\n    annotations = part.annotations.concat(annotations);\n    // filter out duplicates\n    annotations = annotations.reduce((acc, a) => {\n      if (\n        !acc.find(\n          ann =>\n            ann.name === a.name && ann.start === a.start && ann.end === a.end\n        )\n      ) {\n        return acc.concat(a);\n      }\n      return acc;\n    }, []);\n    return { ...part, annotations };\n  };\n\n  render() {\n    const { circular, annotate } = this.props;\n    let { part } = this.props;\n    const partState = this.state;\n    part = annotate ? this.autoAnnotate(part) : part;\n    return (\n      <div className=\"part-explorer-container\" id=\"part-explorer\">\n        <div className=\"seq-viewers-container\">\n          {circular\n            ? part.seq.length > 0 && (\n                <SeqViewer\n                  part={part}\n                  {...partState}\n                  setPartState={this.setPartState}\n                  Circular\n                />\n              )\n            : part.seq.length > 0 && (\n                <SeqViewer\n                  part={part}\n                  {...partState}\n                  setPartState={this.setPartState}\n                  Circular={false}\n                />\n              )}\n          {part.seq.length < 1 && <BlankPage />}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default PartExplorer;\n","import React from \"react\";\nimport PartExplorer from \"./PartExplorer/PartExplorer\";\nimport \"./App.scss\";\n\nlet lattice = {};\nconst Viewer = (part, options) => {\n  const { annotate, circular } = options;\n  if (circular) {\n    return <Circular part={part} annotate={annotate} />;\n  } else {\n    return <Linear part={part} annotate={annotate} />;\n  }\n};\n\nconst Circular = props => {\n  const { part, annotate } = props;\n  return <PartExplorer circular={true} part={part} annotate={annotate} />;\n};\n\nconst Linear = props => {\n  const { part, annotate } = props;\n  return <PartExplorer circular={false} part={part} annotate={annotate} />;\n};\nlattice.Viewer = Viewer;\nexport default lattice;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","export default {\n  name: \"L09136\",\n  seq:\n    \"tcgcgcgtttcggtgatgacggtgaaaacctctgacacatgcagctcccggagacggttgtctgtaagcggatgccgggagcagacaagcccgtcagggcagcgggtgttggcgggtgtcggggctggcttaactatgcggcatcagagcagattgtactgagagtgcaccatatgcggtgtgaaataccgcacagatgcgtaaggagaaaataccgcatcaggcgccattcgccattcaggctgcgcaactgttgggaagggcgatcggtgcgggcctcttcgctattacgccagctggcgaaagggggatgtgctgcaaggcgattaagttgggtaacgccagggttttcccagtcacgacgttgtaaaacgacggccagtgccaagcttgcatgcctgcaggtcgactctagaggatccccgggtaccgagctcgaattcgtaatcatggtcatagctgtttcctgtgtgaaattgttatccgctcacaattccacacaacatacgagccggaagcataaagtgtaaagcctggggtgcctaatgagtgagctaactcacattaattgcgttgcgctcactgcccgctttccagtcgggaaacctgtcgtgccagctgcattaatgaatcggccaacgcgcggggagaggcggtttgcgtattgggcgctcttccgcttcctcgctcactgactcgctgcgctcggtcgttcggctgcggcgagcggtatcagctcactcaaaggcggtaatacggttatccacagaatcaggggataacgcaggaaagaacatgtgagcaaaaggccagcaaaaggccaggaaccgtaaaaaggccgcgttgctggcgtttttccataggctccgcccccctgacgagcatcacaaaaatcgacgctcaagtcagaggtggcgaaacccgacaggactataaagataccaggcgtttccccctggaagctccctcgtgcgctctcctgttccgaccctgccgcttaccggatacctgtccgcctttctcccttcgggaagcgtggcgctttctcatagctcacgctgtaggtatctcagttcggtgtaggtcgttcgctccaagctgggctgtgtgcacgaaccccccgttcagcccgaccgctgcgccttatccggtaactatcgtcttgagtccaacccggtaagacacgacttatcgccactggcagcagccactggtaacaggattagcagagcgaggtatgtaggcggtgctacagagttcttgaagtggtggcctaactacggctacactagaaggacagtatttggtatctgcgctctgctgaagccagttaccttcggaaaaagagttggtagctcttgatccggcaaacaaaccaccgctggtagcggtggtttttttgtttgcaagcagcagattacgcgcagaaaaaaaggatctcaagaagatcctttgatcttttctacggggtctgacgctcagtggaacgaaaactcacgttaagggattttggtcatgagattatcaaaaaggatcttcacctagatccttttaaattaaaaatgaagttttaaatcaatctaaagtatatatgagtaaacttggtctgacagttaccaatgcttaatcagtgaggcacctatctcagcgatctgtctatttcgttcatccatagttgcctgactccccgtcgtgtagataactacgatacgggagggcttaccatctggccccagtgctgcaatgataccgcgagacccacgctcaccggctccagatttatcagcaataaaccagccagccggaagggccgagcgcagaagtggtcctgcaactttatccgcctccatccagtctattaattgttgccgggaagctagagtaagtagttcgccagttaatagtttgcgcaacgttgttgccattgctacaggcatcgtggtgtcacgctcgtcgtttggtatggcttcattcagctccggttcccaacgatcaaggcgagttacatgatcccccatgttgtgcaaaaaagcggttagctccttcggtcctccgatcgttgtcagaagtaagttggccgcagtgttatcactcatggttatggcagcactgcataattctcttactgtcatgccatccgtaagatgcttttctgtgactggtgagtactcaaccaagtcattctgagaatagtgtatgcggcgaccgagttgctcttgcccggcgtcaatacgggataataccgcgccacatagcagaactttaaaagtgctcatcattggaaaacgttcttcggggcgaaaactctcaaggatcttaccgctgttgagatccagttcgatgtaacccactcgtgcacccaactgatcttcagcatcttttactttcaccagcgtttctgggtgagcaaaaacaggaaggcaaaatgccgcaaaaaagggaataagggcgacacggaaatgttgaatactcatactcttcctttttcaatattattgaagcatttatcagggttattgtctcatgagcggatacatatttgaatgtatttagaaaaataaacaaataggggttccgcgcacatttccccgaaaagtgccacctgacgtctaagaaaccattattatcatgacattaacctataaaaataggcgtatcacgaggccctttcgtc\",\n  compSeq:\n    \"agcgcgcaaagccactactgccacttttggagactgtgtacgtcgagggcctctgccaacagacattcgcctacggccctcgtctgttcgggcagtcccgtcgcccacaaccgcccacagccccgaccgaattgatacgccgtagtctcgtctaacatgactctcacgtggtatacgccacactttatggcgtgtctacgcattcctcttttatggcgtagtccgcggtaagcggtaagtccgacgcgttgacaacccttcccgctagccacgcccggagaagcgataatgcggtcgaccgctttccccctacacgacgttccgctaattcaacccattgcggtcccaaaagggtcagtgctgcaacattttgctgccggtcacggttcgaacgtacggacgtccagctgagatctcctaggggcccatggctcgagcttaagcattagtaccagtatcgacaaaggacacactttaacaataggcgagtgttaaggtgtgttgtatgctcggccttcgtatttcacatttcggaccccacggattactcactcgattgagtgtaattaacgcaacgcgagtgacgggcgaaaggtcagccctttggacagcacggtcgacgtaattacttagccggttgcgcgcccctctccgccaaacgcataacccgcgagaaggcgaaggagcgagtgactgagcgacgcgagccagcaagccgacgccgctcgccatagtcgagtgagtttccgccattatgccaataggtgtcttagtcccctattgcgtcctttcttgtacactcgttttccggtcgttttccggtccttggcatttttccggcgcaacgaccgcaaaaaggtatccgaggcggggggactgctcgtagtgtttttagctgcgagttcagtctccaccgctttgggctgtcctgatatttctatggtccgcaaagggggaccttcgagggagcacgcgagaggacaaggctgggacggcgaatggcctatggacaggcggaaagagggaagcccttcgcaccgcgaaagagtatcgagtgcgacatccatagagtcaagccacatccagcaagcgaggttcgacccgacacacgtgcttggggggcaagtcgggctggcgacgcggaataggccattgatagcagaactcaggttgggccattctgtgctgaatagcggtgaccgtcgtcggtgaccattgtcctaatcgtctcgctccatacatccgccacgatgtctcaagaacttcaccaccggattgatgccgatgtgatcttcctgtcataaaccatagacgcgagacgacttcggtcaatggaagcctttttctcaaccatcgagaactaggccgtttgtttggtggcgaccatcgccaccaaaaaaacaaacgttcgtcgtctaatgcgcgtctttttttcctagagttcttctaggaaactagaaaagatgccccagactgcgagtcaccttgcttttgagtgcaattccctaaaaccagtactctaatagtttttcctagaagtggatctaggaaaatttaatttttacttcaaaatttagttagatttcatatatactcatttgaaccagactgtcaatggttacgaattagtcactccgtggatagagtcgctagacagataaagcaagtaggtatcaacggactgaggggcagcacatctattgatgctatgccctcccgaatggtagaccggggtcacgacgttactatggcgctctgggtgcgagtggccgaggtctaaatagtcgttatttggtcggtcggccttcccggctcgcgtcttcaccaggacgttgaaataggcggaggtaggtcagataattaacaacggcccttcgatctcattcatcaagcggtcaattatcaaacgcgttgcaacaacggtaacgatgtccgtagcaccacagtgcgagcagcaaaccataccgaagtaagtcgaggccaagggttgctagttccgctcaatgtactagggggtacaacacgttttttcgccaatcgaggaagccaggaggctagcaacagtcttcattcaaccggcgtcacaatagtgagtaccaataccgtcgtgacgtattaagagaatgacagtacggtaggcattctacgaaaagacactgaccactcatgagttggttcagtaagactcttatcacatacgccgctggctcaacgagaacgggccgcagttatgccctattatggcgcggtgtatcgtcttgaaattttcacgagtagtaaccttttgcaagaagccccgcttttgagagttcctagaatggcgacaactctaggtcaagctacattgggtgagcacgtgggttgactagaagtcgtagaaaatgaaagtggtcgcaaagacccactcgtttttgtccttccgttttacggcgttttttcccttattcccgctgtgcctttacaacttatgagtatgagaaggaaaaagttataataacttcgtaaatagtcccaataacagagtactcgcctatgtataaacttacataaatctttttatttgtttatccccaaggcgcgtgtaaaggggcttttcacggtggactgcagattctttggtaataatagtactgtaattggatatttttatccgcatagtgctccgggaaagcag\",\n  annotations: [\n    {\n      id: \"lxcC1L3M4z\",\n      start: 133,\n      end: 457,\n      direction: \"REVERSE\",\n      name: \"lacZ fragment\",\n      color: \"#8FDE8C\",\n      type: \"CDS\"\n    },\n    {\n      id: \"8DkP5cHpaE\",\n      start: 386,\n      end: 443,\n      direction: \"FORWARD\",\n      name: \"MCS\",\n      color: \"#CFF283\",\n      type: \"misc_feature\"\n    },\n    {\n      id: \"3fdyiQcona\",\n      start: 476,\n      end: 493,\n      direction: \"FORWARD\",\n      name: \"lac operator\",\n      color: \"#9DEAED\",\n      type: \"protein_bind\"\n    },\n    {\n      id: \"lsd_X-s5yM\",\n      start: 500,\n      end: 531,\n      direction: \"REVERSE\",\n      name: \"lac promoter\",\n      color: \"#9DEAED\",\n      type: \"promoter\"\n    },\n    {\n      id: \"mnaEqs-lfH\",\n      start: 854,\n      end: 1443,\n      direction: \"REVERSE\",\n      name: \"ori\",\n      color: \"#CFF283\",\n      type: \"rep_origin\"\n    },\n    {\n      id: \"7GHnMGoV2j\",\n      start: 1613,\n      end: 2474,\n      direction: \"REVERSE\",\n      name: \"bla\",\n      color: \"#8FDE8C\",\n      type: \"CDS\"\n    },\n    {\n      id: \"fPLcYWJU1f\",\n      start: 2474,\n      end: 2579,\n      direction: \"REVERSE\",\n      name: \"bla\",\n      color: \"#6B81FF\",\n      type: \"promoter\"\n    }\n  ]\n};\n","import ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport lattice from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport pUC from \"./DefaultParts/pUC\";\n\nconst part = pUC;\n\nReactDOM.render(\n  lattice.Viewer(part, { annotate: false, circular: true }),\n  document.getElementById(\"app-root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}